数据结构

```tex
1.数据结构的基础知识和理解和掌握成都 以及是否具备对经典数据结构和算法应用能力
   掌握数据结构的基本概念/掌握数据的逻辑结构 存储结构以及基本操作的实现 能够对算法进行基本的时间复杂度与空间复杂度的分析/运用数据结构基本原理进行问题的分析
   和求解 具备采用Java语言设计和实现算法的能力
2. 数据结构的基本概念   
```

数据结构的基本概念:

```java
//将数据相关的内容从小到大进行概括
1：数据项(多个数据项组成一条数据元素)
   一条学生信息是一个学生元素(而对应String name就是一个数据项)
2：数据对象(就是数据元素的一个集合-多个学生的集合)
3：数据类型(值的集合和值上的操作相关)
    原子数据类型 结构数据类型 抽象数据类型(包括操作)
4：数据结构: 逻辑结构 物理结构和对应的操作
    
1：逻辑结构:
  类型: 线性结构(一对一) 图和网状结构(多对多) 树结构(一对多)
  线性与否？: 线性结构和非线性结构
2：物理结构(存储结构/映像)
   顺序存储 链式存储 索引存储 散列存储
3：物理结构不同所对应的优缺点
4：运算的定义和运算的实现针对的是逻辑结构还是物理结构？
```

![image-20220308002552783](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220308002552783.png)

![image-20220308002709448](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220308002709448.png)

逻辑结构的类型

存储结构类型



算法以及描述

```java
//1:基本概念 问题的求解步骤(指令的有限序列)-包含五个特性
1：master公式的掌握 分清楚对应的ab和d利用logaB和d的比值确定答案
```

































##### 对数器和比较器的概念和使用

```java
有一个想要测试的方法a
//Math.random() [0-1)所有的小数 等概率返回一个
//Math.random()*N [0-N)所有小数 等概率返回一个
//(int)Math.random()*N ->[0-N-1]等概率返回一个
    为什么在计算机中可以返回等概率返回内？ 而计算机不可以？
    因为浮点数的表示 基于计算机而言是有穷尽的(精度如果太高的话 就不算了) 而数学是无穷尽的因此决定了此

//比较器的使用 1：实质就是重载比较运算发 2：比较器可以很好的应用在特殊标准的排序上(例如String之类) 3:比较器可以很好的应用在根据特殊标准排序结构上
  对于所有的比较器而言: 返回负数的时候 第一个参数排在前 返回正数的时候 第二个参数排在前面 返回0的时候 谁在前无所谓
```



```tex
1.常数操作: 和数据量没有关系的操作
  数组的赋值 基本的运算(包括数字运算 逻辑运算 以及位运算都属于)
  数组的寻址 verse 和链表寻址之间的区别 链表只是逻辑上数据相邻但是
  寻找依然依靠寻址 但是数组只需要进行下标计算即可
2.选择排序的原理(引出时间复杂度)
  0-N-1为位置 找到最小的数 然后放到0位置
  1-N-1为位置 找到最小的数 然后放到1为位置类推
  常数操作的举例: 
  0-N-1全部都要看一样(N) 
  0-N-1每个都需要和当前最小的数进行比较(N)
  最后找到了最小的数进行交换swap(1)
  0-N-2(N-1) N-1 1 ---以此类推
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220302203017069.png" alt="image-20220302203017069" style="zoom:50%;" />

```tex
最后计算出来的时间复杂度 舍去低项目 将最高次项的系数删剩下的结果
3.同样的时间复杂度如何拼好坏？ 拼常数项
```

```java
public static void process1(){
        int N = 1000;
        int a = 0;
        for (int i = 0; i < N ; i++) {
            a = 3 | 6;
            a = 3 & 4;
            a = 4 ^ 785;
        }
    }
    public static void process2(){
        int N = 1000;
        int a = 0;
        for (int i = 0; i < N ; i++) {
            a = 2+5;
            a = 4*7;
            a = 6*8;
        }
    }
 //选择排序
    public static void selectionSort(int[] arr){
        //1.排除掉捣乱的数组
        if (arr == null || arr.length<2) {
            return;
        }
        //2.保证选择0-N-1
        for (int i = 0; i < arr.length-1; i++) {
            int minIndex = i;
            for (int j = i+1; j < arr.length; j++) {
                //3.比较确定minIndex
                minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            }
            swap(arr,i,minIndex);
        }
    }
    //冒泡排序: 和选择排序相反的是 每一次推到最右边的数字都是最大的数字
    public static void bubbleSort(int[] arr){
        if(arr == null || arr.length<2){
            return;
        }
        for (int i = arr.length-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if(arr[j] > arr[j+1]){
                    swap(arr,j,j+1);
                }
            }
        }
    }

    //在一个数组中 只有一种数字出现了奇数次 其他所有的数字都出现了偶数次 如何找到所有出现奇数次的数
    //2.两种数出现了奇数次 other都出现了偶数次  要求时间复杂度O(n) 空间复杂度O(1)
    /*
    * 第一个问题采用异或的性质 即可因为全部从头到尾全部进行异或
    * 异或不会因为前两者的顺序而改变 最后面都是变成了 a ^ 0的情况
    * */
    public static int printOddTimesNum1(int[] arr){
        if(arr.length < 2){
           return arr[0];
        }
        int i = arr[0];
        for (int j = 1; j < arr.length ; j++) {
            i = i ^ arr[j];
        }
        return i;
    }

    public static void printOddTimesNum2(int[] arr){
        /*
        * 第一次全部进行异或之后剩余的就是a^b
        * 这一定就是意味着a和b有一位(整数的话一共是有32位)数字是不一样的 - 假设是第8位不一样
        * 现在分为第八位全部是1的数 和第八位都不是/ a和b肯定是不同的两边
        * eor'只是去异或第八位是1的数字 出现偶数次的依然不干扰 但是eor'最终肯定就是等于一个a或者b
        * 最后再让eor'去异或eor 即是 a^b^a这样就可以得出另外一个数字了
        *
        * 如何将一个数字的最右边位的1 拿出来
        * 首先获取它的补码(取反+1) - 补码和原码相互与-- 就提取到了最右边的1
        * 然后所有数字和这个只有一个位置是1的数相与- 就可以得出想要的a或者b
        * */
        int emo = 0;
        for (int i = 0; i <arr.length ; i++) {
            emo ^= arr[i]; //异或出来a^b
        }
        int emo1 = 0;
        int rightestOne = emo & (~emo + 1); //一个数同补码进行相与 获取到最右边的一个1
        for (int i = 0; i <arr.length ; i++) {
            if((rightestOne & arr[i]) == 0){
                emo1 ^= arr[i]; //只和该位置上的数为1的数进行相与操作 得到a或者b
            }
        }
        System.out.println(emo1+" "+ (emo^emo1));

    }

```

```java
选择排序 冒泡排序 插入排序 归并排序 细节讲解和对应代码的实现
//1.明白选择排序的原理 是每次将最左边的留出来 存放最小的数 其中就需要一个int index记录对应最小数字的下标
//2. 明白冒泡排序的原理 是每次两两比较最终确定最右边的数字是否为最大的一个操作(并不需要一个int index进行记录)
//3. 解析异或操作 0 ^ 1 - 1 1 ^ 0 - 1 相同异或为0 不同异或为1  长数字运算: 10110 - 00111 -> 10001
//异或运算还可以理解为无进位相加   1. 0^N=N N^N=0  2.异或运算满足交换律和结合律 a^b=b^a a^b^c = a^(b^c) 3.只要是同一批数异或结果一样
//4.解释 a = a^b b = a^b a=a^b -满足了swap方法 
    /*
    1. a = 甲^乙 b = 乙
    2. a = 甲^乙 b = 甲^乙^乙 -> b = 甲(因为相同异或为0 0和任何异或都是他自己)
    3. a = 甲^乙^甲 -> 乙  即是交换成功
    限制就是: 甲和乙必须是不在同一块内存才可满足 / 如果两者在同一块内存区域异或会相当于自身异或自身就直接清零了
    */
 //如何解释上面的交换律以及相同的一些定义问题
 //5.利用无进位相加的想法去理解 本质就是一共数字表示的1个数 来进行相加因为无进位
 //6. 获取一个数二进制最右边为1的方法 - 同自己的补码进行相与
 //7. 因此在插入排序的过程中就引入了 因为同不同数据状况会造成不同的时间复杂度 甚至是需要O(N)水平的时间复杂度 因此判断一个算法的好坏一般只采用最坏即可
 //8.归并排序的原理 根据middle的位置然后左右两侧令其分别排好序 两边排序好之后 利用一个和原来数组同样大小的辅助数组进行拷贝 类似于外排的思想 两两进行比较然后放入内部  那么会问排序的过程在哪里呢？ 当理解了递归的执行之后 你就能明白它本质就是到最底层 一个数 一个数(左右两边)进行排序 就是merge的这一个过程 学递归函数一定要有宏观的思维去理解 但是merge过程要关注和一直确定的是 改变的一直就是arr这个数组上的数 因此需要一个辅助数组help[] 最后完成外排之后再输入内部进去
```



```java
//单调栈的介绍和使用
1:没有重复值的情况 2:有重复值的情况 3：实现
    要每一个数的左边离他最近的比自己小的位置在哪里 和右边离他最近的比他小的
    如果采用任何不优化的方式搞出这样一个数据结构其实也不困难  即是每次到一个数字之后 都需要左右遍历一次 那么对应到的时间复杂度显然就是O(N2)的水平
    所以利用一个空间复杂度为O(n)的栈 并且必须要保证栈的顺序是从下到上从小到大的进行排列 因此就是满足要求
    //具体栈的操作步骤就是: 遇见下面的比自己小当然直接压入 当遇见栈顶比自己大就开始结算了(结算的结果是:  右边第一个比自己小的就是需要压入的值
    //左边比自己小的就是下面也就是自身弹出之后栈顶的值) -- 然后一直就进行清理即可(如果栈还在留着的时候即可) -- 数组中无重复值的情况
    
    2:数组如果存在相同的数值的情况 只需要采用链表类型的记录 然后一起记录到一层即可(其余的就和第一种情况一样)
        有关于对应代码的实现: 需要明确以下的几个点
            1: 既然重复值需要存储到同一层上面那么栈中应该存放一种什么样的数据结构才合理？ - list<Integer>并且需要明确只需要存储对应
                数组arr的下标即可 因为采用arr[i]就可以获得出对应位置上的值
            2：最后这个单调栈应该返回一个什么样的数据结构？ - 返回的是每一个数对应左边和右边最小的位置下标因此显然可以使用int[][]的
                二维数组进行存储 并且行是arr.length的长度而宽度只需要是2 记录如图所示的一个结构
            3：明确每一步采用判断的方式: 
				1:如果比当前数据大当然就是直接创建对应的list压栈即可 2:如果和当前栈顶大小相等只需要往栈顶所在的list填充数字即可
                  3：如果当前的数据小于栈顶就涉及到弹出操作和int[][]二维数组的赋值结算操作(因为可能会引发一连串的赋值操作) 因此需要
                    采用while循环并且存在两个边界一个是 stack.isEmpty() == true和上述小于的条件存在
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307112158943.png" alt="image-20220307112158943" style="zoom: 67%;" />











































线性表的定义和基本操作

线性表的顺序存储结构 顺序表以及基本计算









##### 链表相关内容

```java
链表的一般问题和解决方法:
//1:基本链表类的构造Java也好C++也好
//2：基本单链表的基本操作如何使用Java进行实现
//3: 单链表以及双链表的反转(递归和非递归)
 其中单链表反转的递归操作只要是明确了要返回头(Node作为返回值)
 并且返回一开始的头部就是最后一个指针(这就清楚了改变只能使用
 head进行改变)
//4: 打印相同公共部分的题目: 采用的是外排的思想很快就可以解决
//5: 面试时链表解题方法论 - 额外数据结构(HashMap) 快慢指针方法
//6: 回文链表问题(快慢指针的方法找中点) 主要的问题是偶数个是中点来到的是中间的第一个还是第二个(coding边界的问题)
 如果只是采用有限的几个变量来完成的话/ 先用快慢指针的方式找到链表的
 中点或者是偶数情况下要求的是找到中点的下一个节点，此时开始逆序
 逆序完毕之后记录firstNode和lastNode然后两者重新开始遍历(只要是)
 中间产生错误就是错误 直到两者遍历到Null, 最后再恢复即可
//7.单链表按照某些值划分成左边小 中间相等  右边大的形式
//给定一个单链表的头节点head 结点值的类型是整数型 再给定一个整数pivot 实现一个调整链表的函数 将链表调整为左部份都是值小于pivot的结点 中间部分是等于 右边部分是大于pivot部分 O(N) O(1)
  笔试: 单链表全部放到数组 然后自己搞partition搞完之后重新生成Node即可
  只用6个有限的变量完成: 即是如下图所示(但是一定要清楚 最后相接时候next是否存在(意味着是否有小于等于大于部分))
```

![image-20220307163934757](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307163934757.png)

```java
//8：复制含有随即指针节点的链表 rand指针是单链表节点结构中新增的指针 rand可能指向链表中的任意一个节点 也可以指向null 给定一个由Node节点类型组成无环单链表的头节点head 请实现一个函数完成这个链表的复制 并返回复制的新链表的头节点 O(N) O(1) --采用HashMap进行对应的拷贝即可
首先完完全全拷贝一份 Key是原来的node value对应的是克隆的node
然后重新遍历一次链表 然后对应map,value也对应去找其指向的克隆节点
就可以完成了
不用HashMap完成的方式 首先复制一份每个结点对应的结点穿插到它自己的下面
然后在遍历的时候 理清楚对应的关系即可
```

![image-20220307165759135](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307165759135.png)

```java
code的是实现:
//1:pivot分块的实现
 public static Node pivotPartition(Node head, int pivot){
       if(head == null || head.next == null){
           return head;
       }
        Node sH = null;
        Node sT = null;
        Node eH = null;
        Node eT = null;
        Node mH = null;
        Node mT = null;
        Node next = null;
        //遍历来拼接和建立对应的链表
        while(head != null){
            next = head.next;
            head.next = null;
            if(head.value < pivot){
                //首先判断SH是否有结点 其次判断SL是否和SH一样(一样的情况就是只有一个结点)
                if(sH == null){
                    sH = head;
                    sT = head; //只有一个节点的时候两者是同指针
                }else {
                    sT.next = head;
                    sT = head;
                }
            }else if(head.value == pivot){
                if(eH == null){
                   eH = head;
                   eT = head; //只有一个节点的时候两者是同指针
                }else {
                    //此时SH已经是有结点了
                    eT.next = head;
                    eT = head;
                }
            }else{
                if(mH == null){
                    mH = head;
                    mT = head; //只有一个节点的时候两者是同指针
                }else {
                    //此时SH已经是有结点了
                    mT.next = head;
                    mT = head;
                }
            }
            head = next;
            //小的尾拼接相等部分的头 想等部分的头拼接尾部的头
        }
     if(sT != null){
                sT.next = eH;
                eT = eT == null ? sT : eT;
            }
            if(eT != null){
                eT.next = mH;
            }
        return sH != null ? sH : (eH != null ? eH : mH);
    }
//2.回文的实现
//3.复制随机指针的实现
```

```java
//9：两个单链表相交的一系列问题
给定两个可能有环也可能无环的单链表 头节点head1和head2 请实现一个函数 如果两个链表相交 请返回相交的第一个结点 如果不相交 返回null
如果两个链表长度之和为N 时间复杂度请达到O(N) 额外空间复杂度为O(1)
 思考好对应的几种情况以及如何返回自身单链表成环之后成环的第一个结点
 1:返回两条单链表相交的第一个结点: 快慢指针 当快慢指针相遇的时候(这个时候可以保证链表是存在环的) 然后快指针回到head位置 slow和fast同时走再次相遇的结点就是成环的第一个结点
 2:接下来就是讨论两条链表相交的情况: 
   如果两条链表都不自身成环(则只能够是呈现一个Y字形的相交方式) 至于为什么
   不能出现X是因为单链表规定了一个结点只能有一个next指针
   则这个情况判断的条件就是: 两条链表最后的位置是不是同一块内存地址
   然后要获得第一个相交结点本质就是:找到两者长度只差(n++和n--)找到
   比较长的一条链表令其先走 然后两个同时走第一次相遇的结点直接返回即可
   
   如果两条链表自身成环的话(能够相交只能是两种情况了)
       1: 第一种相交的情况就是: 两者公用一个环 如何判断两者公用一个环？
          就是两者都是存在loop且loop返回的相交结点是一样的
          这个时候要求解两条链表的相交第一个结点： 其实就是将环看作无
          两者成环的结点就是第一种条件的end结点 然后和上述一样的解法
       2：第二种情况就是两者进入环的结点是不一样 这样两者第一次相遇的
          结点就是两个成环结点的任意一个都是正确的
```

```java
//双链表的反转-最后返回的是后来的头结点也就是图上的C结点
 1：对比起单链表的反转(采用迭代的方式) 唯一多的操作就是前指针
    prior需要指向下一个节点
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220310105237908.png" alt="image-20220310105237908" style="zoom: 33%;" />

```java
1:初始化 2:isEmpty() 3:size() 4:push 5:pop() 6:peek()

//2:如何使用单链表结构实现队列:
 1:本质就是要实现一个(类似于链表pivot拼接链表的操作) 就是结点不像是
   头插法的形式进行插入 而是后部进行拓展
 2:则后续进行弹出的方式- 由于栈要满足先进先出因此是头部开始脱离
 3:需要注意的细节是tail的处理(当head==tail时候 删除tail的结点)
    则同时必须要将tail进行清空
//3:单链表实现栈只需要一个变量即可
 1：即是添加的方式采用头插即可(弹出的方式一样同上者一样)
 2：因为并不需要关注head最初的位置-因为弹出时候的时候只需要
    消除上一次刚加入的结点即可
//4:K个一组链表的逆序操作:
  //足够k个结点的内部需要反转 不足的并不需要
     1:小函数的实现: 将k部分一个组结尾的结点进行返回(用于分类)
     2:K部分内部自身进行进行逆序操作
//5：给定两个链表头节点head1和head2 例如1->2->3 就是代表十进制的321然后和另外一个同样表示的大小最后进行相加
     1：小函数-找到链表的长度(找到两个链表分别长度)
        用于长短链表重定向-使用新头l和s
     2：外排形式将两条链表进行遍历(三种情况)
         L有S有 L有S无 L无S无
     3：因此需要有判断进位的方式(每次相加显然mod10来处理-
        需要添加进位) -- 第一个阶段
        只需要L的位和进位进行相加返回即可(如果不继续进位)
        如果是第三种情况还存在进位 直接新建结点即可
//6：两个有序链表的合并 - 外排即可
```















线性表的应用

栈的基本概念

栈的顺序存储结构以及基本运算

栈的链式存储结构以及基本运算

栈的应用

队列的基本概念

队列的顺序存储结构以及基本运算

队列的链式结构以及基本运算

队列的应用

串的基本概念

串的顺序存储结构以及基本运算

串的链式存储结构以及基本运算

##### 递归

```java
//1. 剖析递归行为和递归行为时间复杂度的估算
//2. 用递归方法找一个数组中最大值 系统上到底是怎么做的?
//3. master公式的使用
//如何去书写递归的过程  function(params- 其中参数要写相关的参数) - 本质就是系统进栈(自己推到)
//T [n] = a*T[n/b] + O (N^d) - 分清楚a b d
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220303231905193.png" alt="image-20220303231905193" style="zoom: 25%;" />

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220303232326443.png" alt="image-20220303232326443" style="zoom:25%;" />

```java
Master公式 前面是母过程 子过程(是所有同规模) a表示是子过程的个数 最后是除去了其他所需要规模
    public static int process(int[] arr, int L,  int R){
        //ending point- 结束条件就是左右边界相同
        if(L == R) return arr[L];
        int mid = L+((R-L)>>1);
        int rightMax = process(arr,mid+1,R);
        int leftMax = process(arr,L,mid);
        return Math.max(rightMax,leftMax);
    }
```

```JAVA
//上述的代码总结而言 先明确子过程的规模是多少 显然是调用一半 那么子过程的个数是多少？
//显然一共有两边两个子过程 最后除去子过程需要进行的其他规模是多少 显然是O(1) - 除去调用
//子过程以外剩余的所有时间复杂度
同理为了更好的理解master公式可以拓展到其他不同的情况-例如处理出来前2/3和后2/3部分进行递归
变化的是什么？ - 显然就是只有子过程的数据的规模即是: T(N/2/3) 那么如果分为三段进行递归呢？
 那么显然改变的就是a的值 如果除了子过程进行操作之外进行了打印操作？ 那么就是后者的问题
    总而言之master公式所满足的递归方程都可以很快的计算出来时间复杂度
    以及master公式最后的结论
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220303232807752.png" alt="image-20220303232807752" style="zoom:25%;" />

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220303233710213.png" alt="image-20220303233710213" style="zoom:25%;" />

```java
//归并排序的利用同样可以采用master公式得出想要的结果
  //归并排序

    public static void mergeSort(int[] arr){
        if(arr == null || arr.length < 2)return;
        process1(arr,0,arr.length-1);
    }
    
    public static void process1(int[] arr, int L, int R){
        if(L == R){return;}
        int mid = L+((R-L)>>1);
        process1(arr,L,mid);
        process1(arr,mid+1,R);
        merge(arr,L,mid,R);
    }
    public static void merge(int[]arr, int L, int M, int R ){
        //这个部分完成的是外排的操作
        int[] result = new int[R-L+1]; //确定好result数组的大小
        int i = 0; //拷贝数组的移动下标
        int p1 = L; //左边数组的移动下标
        int p2 = M+1; //右边数组的移动下标
        while(p1 <= M && p2 <=R){
            //这个是当左右一个终结的条件
            result[i++] = arr[p1] >= arr[p2] ? arr[p2++] : arr[p1++];
        }
        //左右有一个终结之后剩下的一个 肯定判断了之后是有序的直接放入即可
        while(p1 <= M){
            result[i++] = arr[p1++];
        }
        while(p2 <= R){
            result[i++] = arr[p2++];
        }
        for (i = 0; i<result.length; i++){
            arr[L+i] = result[i]; //每次改变的是arr内部的 result只是一个辅助数组
        }
    }
master公式进行归并排序的分析
    显然有两个子过程并且每一个子过程都是一个n/2的规模，剩余的规模显然因为一个辅助数组
    将整一个arr也就是说数据量为N 拷贝进入数组那么就是O(n)的水平
    那么a=2 b=2 d=1 因此最终归并排序的时间复杂度 满足logba = d - 即是O(nlogN) 水平
//为什么归并排序能够从n方的时间复杂度 提升到了nlogN水平 从n方的排序算法进行思考 从比较的次数进行思考 第一个数 需要了N次 第二个数需要在0-N-1就是比较N-1次 以此类推浪费大量的比较行为猜才得出了一个数  而归并排序为什么没有浪费？ 因为小部分的比较变成了一个更大部分的有序数组 下次排序就可以省略比较了  因此节省了大量的比较时间因此时间复杂度减低了  额外的空间复杂度: 每次都是准备一个数据量和N一样大空间 因为Java申请了之后会自动释放 因此额外空间复杂度是O(n)
    
//什么是外排序？ 内部两个数组两个指针 比较了之后拷贝到外面的一个数组称之为外排序
```

```java
//小和问题: 首先要清楚小和问题指的是 一个数所有左边比他小的数所有的累加和 首先解法可以采用最原始的两层for循环进行遍历  即是每次遍历内层循环只需要将左边和外层所指向的index对应的arr[index]的大小进行比较 然后一共将所有大小的数字累加起来就是 小和问题: 那么对应的时间复杂度也很难好的可以判断出来 显然就是一个n的等差数列计算出来就是n方的时间复杂度    那么有没有什么方法可以将小和问题求解的时间复杂度缩小到nlogN的水平呢？ 
 //这就涉及到了另外一个角度去思考这个问题  某个数左边所有比他小的数字 其实也可以等价 这个数右边所有比他大数字的和  这时就可以利用起来归并排序的思想 利用归并排序的思想对这个问题进行改写  问题1: 归并排序的过程中处理小和问题是否需要排序呢？ 答案是显然要的 他的本质就是将不同大小进行排序根据当时外排的情况进行判定 而前面已经排完序的就不再要需要计算了  问题2: 如果一个数组中出现了一样的数字应该如何处理呢？？  因为我们处理的方式是一个数字右边所有比他大的数字 那么显然在外排的过程中当左右两个数组大小相等时候 应该把右边数组的数字放到help[]数组中 这个时候当轮到左边数组的时候就可以利用 R-p2+1确定此时右边比他大的个数 就可以得出此时最左端进行结算的情况

//等价的题目: 求解逆序对的多少:  在一个数组中 左边的数如果比右边的数字大 则这两个数构成一个逆序对 请计算出所有的逆序对  逆序对问题和刚才的小和问题唯一的区别就是res的处理 以及是求解右边的数字比左边数字小的情况 因此也很好的可以进行改写 (即是res在相反的情况下 ++即可)
   public static int smallHe(int[] arr){
        return process2(arr,0,arr.length-1);
    }
    public static int process2(int[] arr,int L, int R){
        if(L == R) return 0; //base case当左右两个下标等意味着结束不用结算
        int mid = L+((R-L)>>2);
        return process2(arr,L,mid)+process2(arr,mid+1,R)+merge2(arr,L,mid,R);
    }
    public static int merge2(int[] arr, int L, int M, int R){
        int[] help = new int[R-L+1];
        int p1 = L;
        int p2 = M+1;
        int res = 0;
        int i = 0;
        while(p1 <= M && p2 <= R){
            res += arr[p1] < arr[p2] ? (R-p2+1)*arr[p1] : 0; //唯一只有左边比右边小的时候才结算
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]; //相等的情况例外了出来 就是右边的数组先放入进去(这样就可以在结算的下一轮确定比左边大还有几个数)
        }
        while(p1 <= M){
            help[i++] = arr[p1++];
        }
        while(p2 <= R){
            help[i++] = arr[p2++];
        }
        for (i = 0; i<help.length; i++){
            arr[L+i] = help[i]; //每次改变的是arr内部的 result只是一个辅助数组
        }
        return res;
    }
```

```java
//荷兰国旗问题  问题一 给定一个数组arr 和一个数num 请把小于等于num的数放在数组左边 大于num的数放到数组右边 要求额外空间复杂度为O(1)水平 时间复杂度为O(N)的水平(也没有要求有序)  问题二: 在问题1的条件下还包括了等于num的数放在数组的中间
//问题一的方法就是类似于一个区域的划分 关键是根据划定的数字作为一个区域线 机制是每次比较判断和规定数字大小的比较  如果小于等于那么 当前数字和小于等于区域的下一个数进行交换  区域扩充并且指向下一个数    机制二就是 如果大于那么直接++

//荷兰国旗问题二 所有准备的机制和情况 同荷兰国旗1的问题有了区域上划分的改变 其中添加了一个大于时候交换的方式
//引出了快排的前两个版本 大致上就是利用一个数组中最后一个数字作为分界的num 进行荷兰国旗2上面的操作 然后左右两边的两个数组进行递归的操作完成快排 那么相对应的快排的最坏时间复杂度怎么分析呢？  情况就是所有都是顺序排列的情况就像是123456789 每次选择最后一个 都需要n递减数列情况下的交换顺序 那么就是O(n2)的水平
那么最坏情况的原因是什么呢？ 就是因为划分值处于很偏的位置  因此如果partition方法找到中间的位置 根据master公式就可以推断为类似于归并一样的操作达到了NlogN的水平  那么快排3.0版本的原理就是 找个数利用随机的方法 根据概率分配然后将所有的表达式进行概率累加再求期望可以得出是一个NlogN大致的水平
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220304164711839.png" alt="image-20220304164711839" style="zoom: 50%;" />

```java
  //快排3.0 其中的partition的本质就是返回相等区域的两个左右边界
    public static void quickSort(int[] arr, int L, int R){
        if(L < R){
            swap(arr,(int)(Math.random()*(R-L+1)),R);
            int[] p = partition(arr,L,R); //相同区域的左右边界
            quickSort(arr,L,p[0]-1);
            quickSort(arr,p[1]+1,R);
        }
    }

    private static int[] partition(int[] arr, int L, int R) {
        int less = L-1; //小于区域的边界
        int more = R;  //大于区域边界
        int index = L; //移动的index
        while(index <= R){
            if(arr[index] == arr[R]){
                index++;
            }else if(arr[index] < arr[R]){
                swap(arr,less+1,index); //当前数和小于区域下一个数交换
                less++;
                index++;
            }else{
                swap(arr,more-1,index); //当前数和大于区域前一个数交换
                more--; //大于区域前移 但是index不需要改变
            }
        }
        swap(arr,more,R);
        return new int[]{less+1,more};
    }
```



































递归算法的设计

数组的顺序存储结构

稀疏数组的概念和压缩存储方法

稀疏矩阵的三元组存储结构和基本操作

稀疏矩阵的十字链表存储结构

广义表的基本概念以及存储结构

树的基本概念

##### 二叉树相关内容

```java
//二叉树最先涉及的就是前中后序遍历
1:首先认清递归的本质 并且明白递归序之后在此之前进行改造
2:想要提的一点就是: 就算是不规则的二叉树的前中后序遍历都可以利用
  自身所学习非递归的方式去推导
  并且区分前中后序遍历的不同情况就是: 遍历根结点的时机问题:

3：二叉树前中后序非递归采用的方式和思想
    1：前序遍历: stack进入压入 弹出即打印 先压右再压左(因为栈是逆序)
       因此这种方式先弹出左边的结点因此是正确的(二叉树的深度优先)
    2：中序遍历: 一次性将左边的全部压入(左孩子) 之后即弹出(弹出即打印)
       并且判断是否有右孩子有的话压入重新执行压入左边相同的方式
    3: 后序遍历: 同前序遍历不同的是: 弹出是压入另 外一个栈中 并且
       加入原先栈的是:先压入左边再压右边(最后辅助栈弹出统一打印)
    4：层序遍历(前序的改变只不过利用了queue)
4：二叉树的最大宽度(关于HashMap以及对应结算的机制)
5：如何判断一颗二叉树是否是搜索二叉树？
     1：采用中序遍历将对应的结点值存入到数组中 然后进行遍历判断是否升序
     2：直接利用中序遍历的时候进行check左中右结点的值(用递归的方法来解-简单类型的dp)
6：判断一颗二叉树是否为完全二叉树:
     1：根据定义明确完全二叉树的判定条件明确什么是trigger
         有右无左-直接false 出现了不全孩子的结点之后leaf就启动了(后续必须都是叶子节点)
7: 判断一棵二叉树是否为满二叉树？
     1：采用树形dp的方法 显然就是根据返回的树结点和高度来进行判断(2的h次方-1 用位运算贼帅)
8：判断一颗二叉树是否为平衡二叉树？ -- 二叉树套路相关的题目
     1：采用树形dp的方法简单清晰 - 显然就是根据返回的高度和判断左右子树是否为完全二叉树
9：返回两个结点的最早公共结点
     1：采用HashMap构造出 Key(自身节点) value(父结点)的map 最后两者往上进行遍历最早共同的点
     2：构想出对应可能的情况
         1：o1和o2一方是另外一方的父亲结点 2:两者需要交会之后的父节点
10：返回前驱或者是后继结点(Morris遍历的前驱)
   前驱结点和后继结点的定义(分别是前后者中后继遍历的前后) 
   那么具体位置在哪里呢？
     1.x结点存在右树 那么右树最左边节点就是后继
     2.x结点不存在右数 往上找只要是其父亲的左孩子那么父亲就是x后继结点(需要运用prior指针)
     3.整棵树最右的结点(那么后继节点就是空)
11：二叉树的序列化和反序列化 
12：凹凸折痕问题(二叉树中序遍历转换)
13：快速收集二叉树层数结点的问题:
    拿出此时队列的size有多少 - 就进行②操作多少次(弹出结点 加左加右)
14：路径和大小是否存在等于Sum的情况 -(达到叶结点的一条路径)
       关键是如何判断出达到了叶结点 - 即是左右孩子都为空的时候即是完成
       采用了一个全局变量 当成功有的时候 将原来是false的全局变量改正过来
       但是要注意因为叶结点的值 我规定好了必须要判断root.left因此左右必须不为空的时候我才能继续下去
15.路径和问题2: 需要返回和收集所有的路径 -- 需要清楚引用类型的递归需要copy 以及再不同的过程
      当主过程返回到子过程的时候 需要将原来加入的进行移除操作
16：Morris遍历问题:
  遍历的细节: 假设来到当前结点cur 开始时cur来到头节点位置
  1：如果没有左孩子 cur向右移动-cur = cur.right
  2：如果cur有左孩子 找到左子树最右的结点mostRight - 特就是中序遍历序列的上一个
    a:如果mostRight的右指针指向空 让其指向cur -  cur向左移动cur= cur.left
    b:如果mostRight已经指向了cur 让其指向null 然后cur=cur.right
  3:cur为空时候遍历停止
  用Morris遍历序列来加工先序和中序遍历
      1：先序 - 只能到达一次的直接打印 可以达到两次第一次打印
      2：中序 - 只能到达一次的直接打印 可以达到两次的第二次打印
      (什么时候可以打印两次？ - 有左子树的情况) 没有左子树的情况
      morris序就是只有达到一次的
      1242513637 - 1245367  4251637
      3：后序 - 能回到自己两次第二次才打印(逆序打印左树右边界) 再单独打印
         整棵树的右边界(逆序)
        如何逆序的打印 并且不消耗额外的空间复杂度？ 本质依然是单链表的反转
        只不过是反转了之后再反转回来而已
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220319175031324.png" alt="image-20220319175031324" style="zoom:67%;" />





































##### 图相关内容

```java
1:点集和边集 有向图和无向图的区别(两个点是否左右两点都是到达对面的边)- 就可以默认为一张完好的图
2:邻接表法: 每一个点的以及它的直接邻居(包括之间有权值的图)
3:邻接矩阵法: 一定是正方形的矩阵
4:特殊的图可以采用数组的方式进行表示: 如下图所呈现出来的情况
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220315220041294.png" alt="image-20220315220041294" style="zoom:33%;" />

```java
对应图的构造方式
    1:点集合 - HashMap其中采用了Integer(结点的编号) Node - 对应的value点
    2:边集合 - HashSet其中不允许重复包含 edge类
    3：点Nodes - 包含 入度in 出度out 值value 邻接点nexts 邻接边:edges
    4: 边edge - 权重weight 入点from 出点to
    5: 接口函数 - matrix
         首先根据matrix获得对应上面的值大小 根据图的点击判断是否需要加入点
         根据两个入点和出点创建中间的edge边
         入点的点集需要添加 出度添加 对应另一个点的入读添加- 边集合添加-- 图需要添加新边
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220315221715688.png" alt="image-20220315221715688" style="zoom: 67%;" />

```java
//图的宽度优先遍历
1:同二叉树宽度优先遍历的区别就是: 图弹出结点之后所加入的结点是该点所有
  的nodes边集 - 需要HashSet记录是否已经加入
2：深度优先遍历: 就是宽度优先遍历中的队列变成了Stack栈来实现 但是深度
  优先遍历是一个结点加入的时候进行处理 第二次加入的时候需要将当前结点
  和周围的下一个结点都加入到stack内部
 //为什么需要压回原来的结点？- 因为深度遍历是一个找路径的过程 当然需要返回
   原来的结点再找一条往深处跑的方法
3：拓扑排序算法: 算法的思想: 准备一个zeroInqueue
    第一次进行遍历的时候就是添加 zeroInqueue和完成一个结点对应入°的map
    while(!queue.isEmpty())-弹出一个结点加入results-存放结果的list中
    弹出一个结点就消去其对应nexts结点的in - 如果有新的入°为0再加入queue中即可
4：最小生成树k算法: - 算法要求能够实现类似于并查集或者就是并查集的结构
   k算法思想: 边出发-由小到大-判断出from和to结点是否为同一个结合 如果不是
   result加入边集/并且union 如果是-跳过弹出下一条边
     因为k算法是由一条边对应的to和from结点解锁 对应结点的集合可能会出现
     一大团集合的情况 因此可能会出现的情况就是两个集团的合并 - 因此需要使用类似并查集的结构
5：最小生成树p算法: - 是依靠解锁点然后加入对应的边 -因此只需要使用set或者map结构即可
   算法思想:  判断当前结点是否加入了Set内部 解锁对应的所有边加入到优先级队列(小根堆)
    弹出一条边 判断对应的to结点是否已经加入了 如果没有的话将 边加入results-结果中
    然后同样解锁所有的边放入小根堆中
    其中为了防止树的问题 - 最外层嵌套了一层for循环就是用于消除操作
6：迪杰斯特拉算法 - 单源最短路径算法
      map默认的是结点head到当前结点的距离 <Node,Integer>
      需要返回一个HashMap<Node,Integer> -对应的就是某个点以及对应的最短距离
      还需要一个HashSet用于锁定以及加入过的点
      黑盒getMinDustanceAnUnselectedNode - 找出当前到head结点最短并且没有被选中的点
      解锁了点之后 遍历它所有边以及边的权重 解锁该点对应的to点 判断distanceMap有没有
      更新 如果没有加入map的话(默认开始就是无穷大的长度) - 如果已经加入的就比较
       原来的长度和新路径+当前路径的长度谁比较大即可 - 再锁定一直重复
       
7：并查集结构的实现
   1：外层包裹一层-称之为Element的元素(V)表示泛型
   2：elementMap - value和Element对应 
      fatherMap - 当前Element以及父亲Element对应
      sizeMap - 对应element以及集合的结点的大小
   3：初始化: 用户传入List<V> list -包含了所有的元素值
      elementMap的初始化(自己根据value包圈)
      fatherMap - 初始化都是自己为father
      sizeMap - 初始化自己的size都是1
   4：isSame(V a, V b)操作 - fatherMap查看是否同一个
   5：findHead(V a) - 一直图往上遍历的过程(但是采用了trick stack)
      进行记录之间的路径path - 最后stack弹出进行fatherMap的更改和
      扁平化操作
   6：union(V a, V b)操作 - 判断elementMap是否包含下面元素
      找出sizeMap大的部分(作为父) 
      将小的father改为大的结点  sizeMap改变(大的变多 原来小的删除)
       
8：图的一些基本概念
    （存在强的概念都是有向图才会存在的）
     (存在分量这个概念的: 都是最大的连通子图)
       //图遍历的概念: 必须要防止图是几个连通分量组成的情况 因此在遍历的时候最外层可以嵌套一个for循环来解决这个问题
    稠密图和稀疏图的概念: E < VlogV-可以视为稀疏图
    顶点的度和入度: 无向图而言: 出度=入度=2V  有向图而言: 入度=出度=E
    生成树和生成森林: 包含图中的所有节点的一个极小连通子图(无向图而言)
      非连通图中: 连通分量的生成树构成了非连通图的生成森林
    有向树一个顶点入度为0其余入度都为1
    简单路径和回路的概念: 路径的概念是结点不会重复出现 
         回路是除了第一个节点和最后一个结点之外没有重复出现的序列
    5.12选择题:
     路径定义: Va-Vp中所有经过点组成的序列(长度是之间经过的边的条数)
     //无向图或者有向图给定结点要保证连通图的题目: n-1个结点满足完全图即可
     //然后在这个基础上+1即可
     ADBCCACCCC
```

![image-20220321153504164](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321153504164.png)

![image-20220321153514819](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321153514819.png)

```java
图的存储方式:
1:邻接矩阵方法 -- 表示方法是唯一的
2:邻接表法(顺序+链式存储) -- 表示方法并不唯一
    -首先整体的数组所声明的就是存储对应的图的结点类型
     其中结点的类型包括: data(也就是value) 以及对应的孩子指针
    由于每一个都包括孩子的结点指针: 因此在无向图的情况下必然会存在边的荣誉
    边结点的数量是2E - 整体的空间复杂度为: O(V+2E)
    而有向图的情况: 即是O(V+E)
     显然采用邻接表法如果要寻找入度子结点的话: 需要遍历(不方便)
```

![image-20220321153956076](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321153956076.png)

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321161126652.png" alt="image-20220321161126652" style="zoom:67%;" />

```java
3：最短路径算法
    1：单源最短路径 2：每个顶点之间的最短路径
    其中单源最短路径包括 BFS以及迪杰斯特拉算法
    但是BFS广度优先遍历是按照添加的变来确定 -- 因此不能满足有权图
    迪杰斯特拉: 不允许的是负权值的出现
  其中BFS算法 - 就是简单的图广度优先遍历 - 其中处理的时候即是set不包含
  当前结点的时候 既可以添加
  
  迪杰斯特拉算法: distanceMap -用于记录和返回最终的答案
  每次都通过黑盒获取unselectedMinDistanceNode - 然后解锁它所有的边
  边对应的toNode就是用于处理和更新大小: 如果toNode没有在set中那么就是
  新的结点: 直接添加  当前head->from+weight 就是toNode到head的距离
     如果toNode在set中 只需要比较原来toNode大小和上面的大小是否有更新即可
      
  弗洛伊德算法: 典型是采用dp -对于n个顶点的图G Vi->Vj之间的最短路径可以分为
  以下的几个阶段: 
     初始情况: 不允许依靠其他点进行中转(那么只有相邻的结点才有调剂)
      0：情况允许V0中转  1：允许V0 V1中转 2：
     真正运用的情况是: 本身的大矩阵和path矩阵
     path矩阵初始化 -表示就是需要中转的结点是哪个(初始化就是-1)
     更新的条件简单即是: 当前位置 A[i][j] > A[i][k]+A[k][j] -以K位置表示结点作为中转
  代码实现: 最外层是以Vk为中转点显然(内部即是Matrix的遍历操作)
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321172234707.png" alt="image-20220321172234707" style="zoom:80%;" />

```java
AOE网 - Activity On Edge NetWork - 
带权有向图中 顶点表示事件 有向边表示活动 以边上的权值表示完成该活动的开销(例如完成活动所需要的
 时间) 称之为用边表示活动的网络简称AOE
点表示的只是一个事件(开始只是一个时刻)
1：AOE网包括一个 源点 - 也仅有一个 汇点
2：从源点到汇点 - 路径有多条 所有路径中 具有最大路径长度的路径称之为关键路径 而把关键路径
  上的活动称为关键活动
3：完成最短时间是关键路径的长度 - 如果关键活动不能按时完成 则整个工程完成时间就会延长
4：最早开始事件和最迟开始时间 - 其中最迟开始时间是从后往前推的
   时间余量: 就是最迟开始时间-最早开始时间(表示整个工程所需总时间情况下 可以拖延的时间)
   则 --- 最早开始时间 == 最迟开始时间 - //称之为关键活动 
       //关键活动组成的路径称之为关键路径
```

![image-20220321211508604](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321211508604.png)

```java
1：求所有事件的最早发生时间:
  求出拓扑序列 - 然后进行递推(拓扑排序的序列表示 前面的事件需要完成了之后才能继续执行后面的序列)
  因此在两条路径 - 汇聚到一个点的情况则需要 Max(A1,A2) - 取更大的一个部分
2：求所有事件的最迟发生时间:
  得到逆拓扑排序:(拓扑排序的序列 用stack逆转一下即可)
```

![image-20220321212306665](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321212306665.png)

![image-20220321212521673](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220321212521673.png)

















##### 查找相关内容:

```java
1:静态查找 动态查找
2：线性结构: 顺序 二分 分块查找
3：树形结构 BST AVL B和B+树
4：散列表
5：效率指标 - ASL 成功与失败的情况分析
    
1：静态查找和动态查找的区别:
  检索数据是否在数据中 或者 检索数据中要查找内容的结构特征 ---称之为静态查找
  需要查找表中插入或者一个数据元素
      -例如 BST的插入删除操作 就涉及到了以下的三种情况
        1：如果删除结点是叶结点的话直接删除即可
           public void deleteNode(Node head, int key){
      			if(head.val ==  key){
                    //删除结点是叶结点的情况
                    if(head.left == null && head.right == null){
                        head = null;
                        return;
                        //删除结点是大类2或3
                    }else{
                        if(左空右不空||右空左不空){
                            head = 左子树或者右子树
                        }else{
                            //左右子树都有
                            head.val = f(找到当前结点的前驱结点).val;
                            当前结点再重复情况1或者2
                        }
                        
                    }
                }
      		      判断head.val和key的值分别进行递归
  		}
2:哨兵结点的寻找操作: - 一般寻找的提升操作
  本质就是将下标为0的结点 - 作为进行key值存放的结点 然后从后到头进行遍历寻找这样就
  不需要超过寻找的范围了
  查找效率的分析
    ASL-成功 (1+2+3+...+n)/n - n+1/2
    ASL-失败 (n个元素都是查找失败 需要查找n+1次) - 因此就是 n+1
  
3：对于顺序查找的优化(对于有序表) - 二分查找
   用查找树判定树分析ASL
   有关于查找失败的结点(虽然是查找到父节点层数 但是查找失败本身是有n+1层的)
   按照概率进行分析一共有n+1结点(其中两个n -是因为43下两个查找失败是一样层数)
   
   其他优化方法: 被查找的概率不相等 - 可以将被查找概率大的部分提升到前面的位置
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220322175417304.png" alt="image-20220322175417304" style="zoom:67%;" />

![image-20220322180642454](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220322180642454.png)

```java
1：二分查找的实现
    查找效率的分析: 关键就是将一个序列的查找树画出来 - 然后根据情况分别计算而已
    其中查找成功和朝朝失败的情况不一样
2：折半查找判定树构造- 向下取整的方法(右结点子树比左结点的要多)
         --如果采用向上取整的话 折半查找判定树就是左边比右边要大了
   折半查找判定树一定是平衡二叉树(只有最下面一层屎不满的)
   失败节点数量 = 空链域的数量 = n+1
3:特性: -树高度同完全二叉树一样
```

![image-20220322200011193](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220322200011193.png)

```java
1：分块查找
    大块内无序但是大块之间是有序的
    大块利用索引表进行标记 --- //因此大块可以利用二分查找 内部再用遍历哨兵
    class Struct{
        int maxValue; //表示整个大块内最大的元素可以到多少
        int low,high; 
    }
2：一个小细节为什么索引表最终是 while(low > high)
   因为分块记录的是每一个块最大的位置 因此二分时候查找必须要low>high如果是
   利用到low == height的情况就会出现 mid指向小于部分或者大于部分就没法判定
    
3：ASL效率分析 - 一般不会需要分析讨论
     其中就用顺序查找索引表的方式
```

![image-20220322202859528](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220322202859528.png)

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220322203127447.png" alt="image-20220322203127447" style="zoom: 67%;" />

```java
1:B树
   策略: m叉查找树中: 规定了除了根节点之外 任何结点至少要有
      m/2向上取整分叉 因此包含的关键字是: m/2向上取整-1个关键字
     因为如果每一个分支结点的个数太小的话 就退化成了二叉查找树类似的情况
     相对应的h升高 查找的效率就降低
   另外一个问题: 当head首先就规定好了之后 插入的结点如果都在同一侧一样
     会出现h过高的情况- 因此就涉及到了B树的插入调整问题
   策略: 规定m叉查找树 任何一个节点所有子树的高度都相同
2：B树的特性
    1：B树的阶是什么意思？ - 所有节点的孩子个数的最大值称为B树的阶 通常用m表示
       一棵m阶B树或为空树
    2：每个节点//至多- m棵子树 / 至少就是上面提及的m/2向上取整子树和对应关键字
    3：除了根节点所有非叶结点(至少两个--保证绝对平衡)
    4：所有叶子节点出现在同一个层次(硬性规定)
       
3：结点最大情况的计算:
  含n个关键字的m阶B树 最小高度和最大高度是多少？
    最小高度:让每一层尽量最满即可 

4：B树的插入和删除操作
     1:B树每一次插入都是插入到最底层的节点位置上
     2:插入判断是否超过了最大的关键字个数(m-1) -然后根据情况在m/2向上取整位置进行分裂
```

![image-20220323164244824](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323164244824.png)

```java
1:若删除的关键字在非终端结点: 则用直接前驱或者直接后继来替代被删除的关键字即可
2：如果删除之后关键字结点少于下限情况
     1：兄弟够借的情况 - 右兄弟宽裕 用后继和后继的后继来替代
                     - 左兄弟宽裕 用前驱的前驱来填补空缺
```

![image-20220323165904043](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323165904043.png)

```java
散列查找
   Hash Table - 数据元素的关键字与其存储地址直接相关
   如何建立关键字与存储地址联系？ - 通过散列函数进行映射
   1：一般采用的方式就是直接进行取余的操作
   2：如果取余产生冲突的话: 利用拉链法(用单链表将冲突的进行串联即可)
   3：散列查找
        1：查找成功情况
        2：查找失败情况(不需要将最开始指针的判断算入情况中)
   4：装填因子 = 表中记录数/散列表长度(装填因子会直接影响散列表的查找效率)
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323170756330.png" alt="image-20220323170756330" style="zoom:80%;" />

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323171155422.png" alt="image-20220323171155422" style="zoom:80%;" />

```java
理论上 - 如何设计冲突更少的哈希函数？ -- (散列查找典型的就是 空间换取时间的算法)
    1：p的取值按道理来说取得最接近表长小于或者等于表长的质数m是最佳的选择方式
       因为如果采用合数的话 相对应会产生冲突的情况就会明显的增加
    2：但是不能够教条化 - 关于除留余数法p的选择还是需要根据数据的情况来决定
    3：采用直接定址法: 
      H(key) = a*key+b - 
    4：数码分析法
    5:平方取中法
```

![image-20220323171502460](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323171502460.png)

![image-20220323191058730](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323191058730.png)

![image-20220323191207519](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323191207519.png)

![image-20220323191237060](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323191237060.png)

```java
冲突处理方法 
 1：拉链法
 2：开放定址法 - 是指可存放新表项的空闲地址既向它的同义词表项开放 又向
    它的非同义词表项开放(方法: Hi =(H(key) +di) %m)
    --其中m表示散列表的长度 di为增量序列(i理解为第i次发生冲突)
    增量的设计又分为:
   1:线性探测法 di = 0 1 2 3 ..m-1 --每次往后探测相邻的下一个单元是否为空
       由于原来的HashKey-取余的是根据表长附近的一个质数求出的
       而线性探测法取余的是整一个表长 因此前后两者所确定的范围可能是不同的
       查找的过程中 - 因为线性探测法的局限性因此 同义词和非同义词都可能冲突
                   - 查找失败情况(空位置的判断也需要进行判断)
         区别于: 前面拉链法(因为查找的是空指针 所以不需要计入)
             
       删除操作: 删除节点不能简单地将被删除结点空间置空 否则将接断在它之后填入
                散列表的同义词节点的查找路径 可以做一个删除标记(进行逻辑上的删除)
           
       线性探测法探测效率低的原因在于: 非常容易造成同义词 非同义词的聚集(堆积)
       现象 - 严重影响查找效率
       产生原因 - 冲突后再探测一定是放在某个连续的位置
       ASL的计算方法: 
   2: 平方探测法(更好解决线性探测法 查找堆积的情况)
        非重点小坑: 采用了平方探测法 - 散列表长度m必须是一个表示成4j+3的素数 才能
        探测到所有的位置
   3：伪随机序列法
3：再散列法(更新一个新的散列函数即可)
```

![image-20220323195118492](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323195118492.png)

![image-20220323195619008](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220323195619008.png)

















##### 串相关算法:

```java
KMP算法: -判断是否为字串的问题
    1:前缀数组的概念 - 一个字符前面最大前后相等的长度(不能包括整体)
    2:next数组是-str2也就是短数组(模式串)
```































































二叉树与树森林之间的转换

二叉树顺序存储结构和链式存储结构

二叉树的基本运算

二叉树的遍历

二叉树的构造

图的基本概念

图的存储结构

图的遍历

最小生成树

最短路径

拓扑排序

关键路径

查找的基本概念以及效率的评价方法

线性表的查找 顺序查找 二分查找分块查找

树表的查找 二叉树排序树 B-树

哈希表的基本概念 哈希函数的构造和处理冲突的基本方法

排序的基本概念

插入排序 直接插入排序 折半插入排序 希尔排序

交换排序 冒泡排序 快速排序











































##### 排序相关内容

```java
//堆结构: 1：堆结构就是用数组实现的完全二叉树结构  2：完全二叉树中如果每颗子树最大值在顶部的就是大根堆 相反最小值在顶部的就是小根堆(必须满足每一颗子树都是如此) 3：堆结构中最关键的就是heapInsert和heapify操作 4:堆结构的增大和减少 5：优先级队列结构(就是Java提供给外部的堆结构)
提出了一个问题 一个连续的数组结构和完全二叉树应该如何对应？ 1：首先要明确的就是size它决定了必须从0开始作为下标连续的size个值逻辑上构成了完全二叉树
    2:左孩子和右孩子的记录: 2*i+1以及2*i+2 父下标: i-1/2(其中在计算机当中 0-1/2答案依然是0)
//其中heapInset的用法: 拿小根堆为例某个数在数组中插入 肯定是要在后面的位置 因为要进行比较和调整 就需要一一的和父节点进行比较 则明显只需要通过下标即可完成
//当跑到0之后进行运算之后会发现依然满足  heapfy操作: 即是将根堆的最顶的数据拿出来之后 重新调整大小根堆的方式 即是在下方有孩子的情况下 抽取出左右两个孩子中比较大的一个 然后再同父亲(即是index本身)进行比较 当自身依然比孩子都大的情况下即可跳出循环 否则以此类推
 复杂度的分析: 明显的是heapify和heapInsert所要进行执行的高度就是整棵逻辑层面上的完全二叉树的高度 因此就是logN的时间复杂度 当明确了heapinsert和heapify两个过程之后就可以理解堆排序的过程: 其本质就是heapsize从0开始 每次插入一个数字先令其heapInsert再进行heapfiy调整直到完成整一个数组的过程 最后面有一个处理 当最大值来到最后一个位置之后和堆断开联系(第一个数和最后一个) 每次断连之后就意味着最大的数字已经确定 剩下的只需要继续操作剩余数组重复上述的过程即可
     
     
 //堆排序 1: 先堆插入 2: 开启尾部和顶部调换然后尾部脱钩重复进行heapify直到heapsize为0
    //显然复杂度进行分析的话 主要是第一次for循环heapInsert的过程中 额外的空间复杂度显然只需要几个常量而已 只需要O(1)唯一一个减少的空间复杂度
    public static void heapSort(int[] arr){
        if (arr == null || arr.length < 2) {
            return;
        }
        //首先整体进行heapInsert主要先确定最尾部的一定是最大的值(到时候脱钩断链需要使用)
        for (int i = 0; i < arr.length; i++) { //O(n)
            heapInsert(arr,i); //O(logN)
        }
        int heapSize = arr.length;
        //重复将尾部进行脱钩然后次尾部和首部进行替换重新执行heapify的过程
        swap(arr,0,--heapSize);
        while(heapSize > 0){ //O(N)
            heapify(arr,0, heapSize); //O(logN)
            swap(arr,0,--heapSize); //O(1)
        }

    }

    public static void heapInsert(int[] arr, int index){
        //某个数现在处于index位置 往上继续移动(小根堆为例子)
        while(arr[index] < arr[(index-1)/2]){
            swap(arr,index,(index-1)/2);
            index = (index-1)/2;
        }
    }

    public static void heapify(int[] arr, int index, int heapSize){
        //heapify是从上到下重新进行调整的过程 目的是交换了之后 要将最大的index放入到数组的最后 然后为了下一次的脱钩 
        int left = index*2+1;
        //终止条件就是孩子脱钩
        while(left < heapSize) {
            //这里需要注意一个细节 就是要保证右孩子也是小于heapSize的(heapSize是个数而right和left是对应的下标)
            int largestIndex = (arr[left] > arr[left + 1])&&(left+1 < heapSize) ? left : left + 1; //两个孩子之中选择出来更大的一个
            largestIndex = arr[largestIndex] > arr[index] ? largestIndex : index; //当前(也就是父亲和两个孩子相比较)
            if(largestIndex == index){
                break; //如果最大的已经是自身的话 就可以直接跳出循环了
            }
            swap(arr,largestIndex,index); //其实说明较大的是父亲的两个孩子其中的一个
            index = largestIndex;
            left = index * 2+1;
        }
    }

//堆排序的拓展题目 一直一个几乎有序的数组 几乎有序是指 如果把数据排好顺序的话 每个元素移动的距离可以不超过k 并且k相对于数组来说比较小 请选择一个合适的排序算法针对这个数据进行排序
因为规定了一定范围内移动k上的数字进行排序 因此只需要准备一个大小k+1的小根堆每次放入heapSize大小 每次确定出堆顶最小值 然后弹出重新插入这一个过程 即可实现
时间复杂度进行分析: 因为for一直前进 内部k数据量的根堆调整: 显然答案是: n*logK
    public static void sortedArrDistanceLessK(int[] arr, int k){
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        //首先K+1个数值加入到小根堆--满足改变的距离是k
        int index = 0;
        for (;index <= Math.min(k,arr.length); index++){
            heap.add(arr[index]);
        }
        int i =0;
        //弹出和加入的过程
        for (; index < arr.length; index++) {
            arr[i++] = heap.poll();
            heap.add(arr[index]);
        }
        //剩余在堆中还有k-1个数全部加入即可
        while(!heap.isEmpty()){
            arr[i++] = heap.poll();
        }
    }
```



```java
//不基于比较的排序(区别于之前基于比较的排序) 桶排序
//思想： 桶排序思想下的排序都是不基于比较的牌  时间复杂度为O(N) 额外空间复杂度是O(M)  引用范围有限 需要样本的数据状况满足桶的划分
计数排序: 缺点就是对于排序的值有固定的安排否则根据计算机整数的范围要声明 范围+1的桶并不实际 基本的流程就是声明已知范围+1数量的容器 然后将对应的数据放入到不同的桶中 最后再一一提取即可
基数排序: 本质上是根据进制的优先级进行排序的分配 并且得出最终的答案(因为对于十进制而言 从个位 十位分别经历铜排) 倒入和倒出的行为就能够满足此类的排序
基数排序优秀的点就是在于: 并不像是计数排序按照数字范围进行排序而是依靠进制来区分
    
//1. 计数排序: only for no_negative value
     首先一个函数为maxBit目的就是为了统计所有数字中最大的进制数(一般是按照十进制的情况进行获取值)
     其中在代码的优化利用了将 数字和用前缀和替换的方法 类似切片的性质 再利用从右往左进行遍历而实现出桶的问题
     小方法: getDigit(int x, int d)-目的是为了获得对应进制位上的数字
```

```java
//排序算法的稳定性及其汇总
同样值的个体之间 如果不因为排序而改变相对次序 就是这个排序是有稳定性的 否则就是没有
不具备稳定性的排序: 选择排序 快速排序 堆排序
具备稳定性的排序: 冒泡排序 插入排序 归并排序 一切桶排序思想下的排序
目前没有找到时间复杂度位O(n*logN) 额外空间复杂度O(1) 又稳定的排序
    排序是否稳定性的应用在一般基础类型的排序是没有用处的 但是在不具有排序稳定性的排序而言(比如学生的群体来比较是区别)
    例如首先对于学生群体的排序第一次利用age来排序 再此基础上再对应例如班级的大小进行排序 那么如果两次都是按照稳定性进行排序的话
    就会出现不一样的情况
    1： 选择排序而言 如下图所示选择排序寻找到第一个比它小的数字 这里获得了1 然后进行交换 那么显然越过了中间相同数值的很多3 显然是不稳定的
```

![image-20220307012448858](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307012448858.png)

```java
2：冒泡排序而言因为前后两两都是会进行交换的 那么显然两者交换都是稳定的
3: 插入排序显然可以操作当左边比右边小的时候不插入而保持了稳定性
4：归并操作实现稳定性的关键是merge的操作 如果相等的时候先拷贝左边即可(但是小和问题是先放右边 虽然排序是正确的但是失去了稳定性)
5：快速排序: 关键是partition无法做稳定性 如下图所示当以5进行划分的时候(采用小于等于区域的划分 就是除了less要操作其余直接++)
   显然这里当到了第三的时候 是需要less区域的下一个和当前的3进行交换 那么显然6就绕过了其他的6 因此快排就不再具有稳定性了
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307013017089.png" alt="image-20220307013017089" style="zoom:50%;" />

```java
6：堆排序是只需要保持他是一棵完全二叉树的性质: 在heapInsert生成大根堆的时候 很容易就因为调整堆结构的时候 导致物理内存存放的位置进行了变化
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307013311434.png" alt="image-20220307013311434" style="zoom:25%;" />

```java
7.桶排序本身就是利于桶 不基于比较的排序显然就是可以保持稳定性的
//有关于时间复杂度 空间复杂度 稳定性来排序(一般排序而言我们使用快速排序)
    因为经过了实验的比较之后 快排的常数项的时间更低
    merge Quick HeapSort都是各有优点
    上述总结了之后需要理解的就是: 从上述的三个角度去分析一个排序算法的适用场景 例如如果样本量小的话就可以不妨使用插入排序 因为尽管排序的时间复杂度是O(n2)的水平 但是样本量小的时候是远远达不到要求算法的时间边界的 另外排序非常规比较的排序显然就要考虑是否要包含稳定性， 在要求额外空间复杂度低并且时间复杂度是NlogN水平显然就需要考虑merge规定相等时候左边先投入的归并排序
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307013515909.png" alt="image-20220307013515909" style="zoom:50%;" />

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307014110170.png" alt="image-20220307014110170" style="zoom:50%;" />

```java
//哈希表的简单介绍:
1:哈希表在使用层面上可以理解为一种集合结构
2：如果只有key 没有伴随数据value 可以使用HaseSet结构(C++UnOrderedSet)
3:如果有key且有value 可以使用HashMap结构(UnOrderMap)
4:有无伴随数据 是HashMap和HashSet的唯一区别 底层实际结构是一回事
5:使用Hash表增 put remove等可以认为时间复杂度为O(1)的水平 但是常数
  时间上的水平很大
6:放入HashMap的东西 如果是基础类型 内部按照值传递 内存占用就是这个东西大小
7：如果不是基础类型 内部按照引用传递 内存占用的就是这个东西的内存地址大小

//有序表的简单介绍:
1:有序表在使用层面上可以看成是一种集合结构
2：key但是没有value可以使用TreeSet(OrderedSet)
3:同理既有key也有value可以使用TreeMap结构(OrderedMap)
4:有无伴随数据是treeSet和map之间最大的区别 底层实际是一回事
5:红黑树 AVL树 size-balance_tree和跳表等都是属于有序表结构 只是
  底层具体实现不同
6：放入有序表的东西 如果是基础类型 内部按照值传递 内存占用就是这个东西的大小
7：放入有序表的东西 如果不是基础类型 必须提供比较器 内部按引用传递 内存
   占用是这个东西内存地址的大小
8：不管是什么底层具体实现 只要是有序表 都有以下固定的基本功能和固定的时间复杂度
有序表必须要求key是可以比较的(基本类型天生就是可以比较)
    
    

区分按照引用进行传递和按照值进行传递之间的区别:
引用传递的就是传地址 按照引用传递的就是值的地址
```

![image-20220307151901562](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307151901562.png)

![image-20220307152117228](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307152117228.png)

![image-20220307152143182](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220307152143182.png)





##### 栈和队列相关

```java
1: 栈的括号匹配问题
    最后出现的左括号最先被匹配(LIFO) - 可用于栈的特性来实现
    基本就是出现一个右括号必须当前的peek和对应的左括号对应(同时要注意是否栈为空)
    最后当遍历完数组之后 判断栈是否为空即可
2：栈在表达式求值中的应用(操作数的前后顺序不能颠倒) -- 必须要左优先原则
    逆波兰表达式 - 后缀(所谓就是操作数的地方)
    波兰表达式 - 前缀
   中缀(就是普通的等式写法)转后缀
    1:确定中缀表达式中各个运算符的运算顺序
    2：选择下一个运算符 按照 左右操作数运算符的方式组合成一个新的操作数
    3：如果还有运算符没被处理 就继续2
   什么是左右先原则？ - 入下图所示A+B和C*D的顺序问题 - 因为两者的先后计算并不会
   影响最后输出的结果 因此按照左优先原则最终就是先计算A+B
     使用计算完成的话: 后缀表达式求值 - 也是满足LIFO的过程
       遇见操作数就压栈- 遇见一个操作符就弹出两个操作数进行运算合并
       计算到数字之后压栈即可 - 一直重复加入完成之后最后栈顶的元素就是最后的答案
```

![image-20220324112807959](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220324112807959.png)

```java
   public static boolean match(String s){
        char[] arr = s.toCharArray();
        Stack<Character> stack = new Stack<>();
        if(arr[0] == ')' || arr[0] == ']' || arr[0] == '}'){
            return false;
        }else {
            stack.add(arr[0]);
        }
        for (int i = 1; i < arr.length; i++) {
            if(arr[i] == ')'){
               if( !stack.isEmpty() && stack.peek() == '('){
                   stack.pop();
               }else {
                   return false;
               }
            }else if(arr[i] == ']'){
                if(!stack.isEmpty() &&stack.peek() == '['){
                    stack.pop();
                }else {
                    return false;
                }
            }else if(arr[i] == '}'){
                if(!stack.isEmpty() && stack.peek() == '{'){
                    stack.pop();
                }else {
                    return false;
                }
            }else {
                stack.add(arr[i]);
            }
        }
        return stack.isEmpty();
    }
```

```java
3：后缀转中缀 - 根据对应的性质进行计算即可
   中缀转前缀(满足右优先原则即可)
4:中缀表达式 转 后缀表达式(机器实现)
     初始化一个栈 - 用于保存这哪是还不能确定运算数序的运算符
     遇到操作数 - 直接加入后缀表达式
     遇到界限符 - 遇到(直接入栈 遇到)一次弹出栈内运算符并加入后缀表达式 直到弹出(为止
                 其中(不加入后缀表达式
     遇到运算符 - 依次弹出栈中优先级高于或等于当前运算符的所有运算符 并加入后缀表达式
                 若碰到( 或栈空则停止  之后再把当前运算符入栈
```

![image-20220324134135630](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220324134135630.png)

```java
5：中缀表达式的计算(机器运算)
    采用 - 中缀转后缀之后 - 再用后缀表达式进行求值即可
```

![image-20220326111600807](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220326111600807.png)

```java
特殊矩阵的压缩
    1：数组存储结构 一维数组 二维数组
    2：特殊矩阵 - 对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵
```



















































归并排序

```java
//1. 二分法的详解和拓展: 
/*
在一个有序数组中 为了去查找另外一个数字是否存在 
在一个有序数组中 找到>=某个数最左侧的位置  --- 同第一个的区别是前者只需要二分到找到这个数即可 但是这个找到最左需要二分到结束
局部最小值的问题
*/
常规而言是有序才能二分 但是实际上二分所应用到的情况只要是左右两边可以甩到一边最后得出答案的即可
```



基数排序

各种排序算法的比较







1：双链表

2：循环链表

3：静态链表

4：顺序表和链表的比较

5：双端队列

6：栈相关内容的应用

7：特殊矩阵的压缩存储

8：线索二叉树

9：树,森林相关

10: 树与二叉树的应用(主要是哈夫曼树和哈夫曼编码)

11：图的所有内容

12：查找所有内容

13：折半插入排序 希尔排序

14:各种内部排序比较和应用/外部排序

15:串相关内容





CodeBlock:

```java
//CodeBlock机器测试操作 - 需要解决完100道题
下载mingw带有编译器的 - 
N诺-官网
  C语言的输入输出技巧 
    int - scanf("%d",&x);
    float -直接用double
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220319151509499.png" alt="image-20220319151509499" style="zoom: 80%;" />

```c++
//1091 - 简单的if else语句
1:注意细节如果出现小数的情况应该如何？ -double  %g取除小数后面多余的0
```

![image-20220319160428553](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220319160428553.png)



















































## 1. 贪心算法 - day 2021 7 14

基本的想法？ 一个贪心算法我们实现的步骤是什么？ 

- 实现一个不依靠贪心策略的解法X 可以用最暴力的尝试

- 脑补出贪心策略A B C

- 用解法X和对数器 去验证每一个贪心策略 最后用实验的方式验证

- 不要纠结贪心策略是如何证明的

  ### **1.Program Problem**

  - 贪心策略1: 开始时间最早的?

  - 贪心策略2: 持续时间最短的?

    简单的发现举反例就可以验证都是错误的

    应该采用结束时间最短的进行采用的方式

    ```java
    //1.Program class --- 贪心算法利用堆进行处理的特别多
    public class Program{
        public int start; //开始时间
        public int end;
        public Program(int start, int end){
            this.start = start;
            this.end = end;
        }
        //2.定义比较器
        public class ProgramComparator implements Compartor<Program>{
            @Override
            public int compare(Program o1,Program o2){
                return o1.end - o2.end; //小根堆的方式(根据结束时间)
            }
        }
        //3.给予会议的数组，以及是timepoint记录此时的时间
        public int bestArrange(Program[] programs, int timePoint){
            Arrays.sort(programs, new ProgramComparator());
                int result = 0;
                for (int i = 0; i < programs.length ; i++) {
                    if (timePoint <= programs[i].end) {
                        result++;
                    }
                    timePoint = programs[i].end;
                }
                return result;
        }
    }
    ```

    ### 2.字典序的比较问题

    - 同样长的长度 通过对应的26进制的计算直接比较两个字符的大小(abc) a*26²+b*26+c
    - 如果是不一样的长度 通过将短的用0补充到和长的一样大小

       直接使用两者的字典序大小来决定谁在前在后？ -> 来组合成新的字符串 ❌

       应该使用a.b(a结合b之后和b结合a之后进行比较)

    ```java
    //2.按照字典序进行排序的问题
        public static class MyComparator implements Comparator<String>{
            @Override
            public int compare(String o1, String o2) {
                //java中的compareTo方法 返回的就是字典序的方法
                return (o1+o2).compareTo(o2+o1);
            }
        }
    
        public static String lowestString(String[] strs){
            if (strs == null || strs.length == 0) {
                return "";
            }
            Arrays.sort(strs, new MyComparator());
            String res = "";
            for (int i = 0; i < strs.length ; i++) {
                res += strs[i];
            }
            return res;
        }
    ```

    **证明: 比较策略是一个有效的方式**

    1. 比较的方式应该要具有一种传递性({甲,乙,丙}--进行排列是不具有比较性的-因为没有大小的传递性)

    ​      日常的比较:{1,2,3}--天然具有传递性 

    ​	2.则需要证明: a.b <= b.a b.c<=c.b --> a.c <= c.a

    ```markdown
    1.str->k进制 'abc' 'de'
    'abc'*k² +'de'(abc向左边移动两位)
    证明的方式如下 所示已经证明这种方式拼接存在排序的传递性
    ```

    ![image-20210714092915251](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714092915251.png)

    ![image-20210714093141130](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714093141130.png)

  ```markdown
  2.证明上面的方法 进行排序拼接的字符串拥有的字典序顺序问题
  1.[...m1,a,b,m2...]
  2.[...a,m1,m2,b...]
  3.[...a,m1,m2,m3,b...]
  .
  .
  n...
  交换的过程中因为本身原始序列a在前面 或者b在前面序列是最小的
  因此在交换的过程中 字典序都是会变大的
  ```

  ![image-20210714093555482](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714093555482.png)

  ![image-20210714093611445](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714093611445.png)

  ### 3.切金条问题:

   题目描述: 一块金条切成两半 需要花费和长度值一样的铜板 比如长度为20的金条 不管切成长度多大的两半 都要花费20个铜板

  一群人想分整块金条 怎么分最省铜板？

  [10,20,30] 代表三个人 整条长度为60

  可以: 60 - 10 / 50 - 20 30  (一共就是60+50 = 110)

  或者 60 - 30 / 30 - 20 10 (一共就是60 +30 = 90) 输入一个数组 返回最小的代价

  ```java
  public static int lessMoney(int[] arr){
          PriorityQueue<Integer> pQ = new 		  PriorityQueue<>();
          for (int i = 0; i <  arr.length; i++) {
              pQ.add(arr[i]);
          }
          int sum = 0;
          int cur = 0;
          while(pQ.size() > 1){
              cur = pQ.poll() + pQ.poll();
              sum += cur;
              pQ.add(cur);
          }
          return sum;
      }
  /*
  此处的思想就是经典的哈夫曼编码问题 - 此处首先将所有的切块方法放入小根堆 - 目的就是取出两个最小的花费的方式(算累加和 再合成 最后的结果堆就是只有一个数字) -- 自底向上的方法
  */
  ```

  ![image-20210714094711421](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714094711421.png)

  ![image-20210714094716956](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714094716956.png)

  ![image-20210714094725714](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210714094725714.png)

  已知有n0个叶子节点 -> n = n0+n1+n2 = n0 + n2 = 2n0 - 1

  

  ### 4.项目利润的问题

  - 贪心策略明显就是: 在最小的初始资金的时候 去找一个利润最大的项目去做 - 小根堆存放cost 大根堆存放profit最大的

  ```java
  public static class Node{
          //Node - 代表项目(p 代表Profit  c 代表cost(起始cost))
          public int p;
          public int c;
          public Node(int p, int c){
              this.p = p; //Profit
              this.c  = c; // Capital
          }
      }
  
      public static class MinCostComparator implements Comparator<Node>{
          @Override
          public int compare(Node o1, Node o2) {
              return o1.c - o2.c; //小根堆 - 根据花费从小到大进行排列
          }
      }
  
      public static class MaxProfitComparator implements Comparator<Node>{
  
          @Override
          public int compare(Node o1, Node o2) {
              return o2.p - o1.p; //大根堆根据利润从大到小进行排列
          }
      }
  
      public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital){
          //k 代表一共可以做多少个项目 W 代表的是利润(起始表示的是一个初始资金)
          PriorityQueue<Node> minCostQ = new PriorityQueue<>(new MinCostComparator());
          PriorityQueue<Node> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
          for (int i = 0; i <  Profits.length; i++) {
              minCostQ.add(new Node(Profits[i],Capital[i]));
          }
          for (int i = 0; i < k ; i++) {
              while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
                  maxProfitQ.add(minCostQ.poll());
              }
              if (maxProfitQ.isEmpty()) {
                  return W;
              }
              W += maxProfitQ.poll().p;
          }
          return W;
      }
  ```

  ### 5.数据流中位数的问题

  ```
  小根堆解决 (第一个先进入大根堆 判断即将要进入的数字有没有大根堆的堆顶数字大 没有的话进入大根堆 有的话进入小根堆)
  //每一次解决之后 判断大根堆和小根堆的差距是否超过了1 -- 如果是的话将多的一方栈定弹出进入另一个根堆
  ```

  ```java
  public static class MinComparator implements Comparator<Integer>{
          @Override
          public int compare(Integer o1, Integer o2) {
              return o1 - o2; //小根堆
          }
      }
      public static class MaxComparator implements Comparator<Integer>{
          @Override
          public int compare(Integer o1, Integer o2) {
              return o2 - o1; //大根堆
          }
      }
  
      public static class MedianFinder{
          static PriorityQueue<Integer> max;
          static PriorityQueue<Integer> min;
          public MedianFinder(){
              max = new PriorityQueue<>(new MaxComparator());
              min = new PriorityQueue<>(new MinComparator());
          }
          public static void addNum(int num){
              //起始保证加入的是大根堆，并且中位数保存在大根堆中
              max.add(num);
              min.add(max.remove());
              if (min.size() > max.size()) {
                  max.add(min.remove());
              }
          }
  
          public static int getMidestNumber(){
              if (max.size() == min.size()) {
                  return (max.peek() + min.peek()) / 2;
              }else{
               return max.peek();
              }
          }
      }
  ```

  ### 6. N皇后问题

  - 解决思路：固定行 进行深度优先遍历，此时只需要检查和列以及和斜线是否可以满足条件 
  - 其中斜线满足条件->斜率问题 
    - 利用一维数组可以利用下标和值的关系进行存储

  ```java
  public static int num1(int n){
          if ((n<1)) {
              return 0;
          }
          int[] record = new int[n];
          return process1(0,record,n);
      }
  
      public static int process1(int i, int[] record, int n){
          if (i == n) {
              return 1;
          }
          int res = 0;
          for (int j = 0; j < n ; j++) {
              if (isValid(record,i,j)) {
                  record[i] = j;
                  res += process1(i+1,record,n);
              }
          }
          return res;
      }
  
      public static boolean isValid(int[] record, int i, int j){
          for (int k = 0; k < i; k++) {
              if (j == record[k] || Math.abs(record[k] -j) == Math.abs(i-k)) {
                  return false;
              }
          }
          return true;
      }
  ```

  

## 2. 暴力递归 -  day 2021 7 15

   1.**汉诺塔问题 - 打印即可**

- Hannuo Tower -  采用的是递归解决 需要把握的是 你需要关注的是第i步需要完成的事情

- 需要满足必须小的在上

- 几个步骤: 三个部分 start end others 一共有i个塔盘

  ```java
  public static void HannuoTower(int i, int start, int end, int others){
      //B
      if(i == 1){
           System.out.println("Move 1 from" + start + " to " + end);
      }else{
      //1.第一个塔盘移动到others
      HannuoTower(i-1,start,others,end);
      //2.将本身移动到目的
      System.out.println("Move "+ i + " from " + start+ " to " + end);
       //3.最后将其他的塔盘移动到目的
      HannuoTower(i-1,other,end,start);
      }
  }
  ```

  

2. **打印一个字符串的所有字串- 打印即可** 

   - 既然是暴力递归的问题？ 那么是从什么位置 什么形式进行递归？ - 一般从左往右

   - BaseCase是什么？ - 一般就是所谓的边界条件(结束条件 限制条件) - 达到str.length

   - normalCase？ - 当第i个字符的时候 需要加入本字符 或者 不加入？

     ```java
     public static void process(Char[] str, int i){
         if(i == str.length){
            System.out.println(String.valueOf(str));
                 return;
         }
         process(str,i+1); //将当前的字符加入str中
         char tmp = str[i];
         str[i] = 0;
         process(str,i+1); //选择不加入当前的字符
         str[i] = tmp; //理解肯定需要还原(然后返回到上一层的递归中)- str存储在系统栈中
     }
     
     public static void printAllSubsquence(String str){
             char[] chs = str.toCharArray();
             process(chs,0);
         }
     ```

     

3. ##### 打印一个字符串的所有子序列 并且所有子序列不重复打印-- 返回的是存储List，可以在main中进行打印查看

   - BaseCase是啥？ - 同上一样就是当str.lenght = i的时候 进行打印

   - 既然是暴力递归问题？递归的方式是？同样是从左往右

   - normalCase? - 本字符是否和后面的字符进行交换？

   - 如何完成不重复？ 一个缓存的机制可以采用一个flag 但是你需要26个应该采用数组的机制boolean value

     ```java
     public static void process1(char[] str, int i, ArrayList<String> res){
         if(str.length == i){
             res.add(String.valueof(str));
             return;
         }
         boolean[] values = new boolean[26];//分支限界
         for(int j=i, j<str.length; j++){
             if(!values[str[i]-'a']){
                 values[str[i]-'a'] = true;
                 swap(str,i,j);
                 process1(str,i+1,res);
                 swap(str,i,j); //关注于本层递归交换之后换为原样
             }
         }
     }
     public static void swap(char[]str, int i, int j){
             char tmp = str[i];
             str[i] = str[j];
             str[j] = tmp;
         }
     ```

     

   ##### 4.纸牌抽牌获胜的问题：-- 返回的是最后返回的最大点数

   - 暴力递归？- 所以方式是？ 从左往右？- 这里是两边进行因此递归的方式应该是类似于子区间的一种方式

   - BaseCase？ 左边i = 右边N(只有一张牌)

   - normalCase？ - 这里区分的是两个人 应该存在于先手函数和后手函数(默认是必须选择一张牌)

     ```java
     public static int F(int[] arr, int L, int R){
         if(L == R){
             return arr[L];
         }
         return Math.max(arr[L]+S(arr,L+1,R),arr[R]+S(arr,L,R-1)); //先手抽取了 后手的normal case
     } 
     
     public static int S(int[] arr, int L, int R){
         if(L == R){
             return 0;
         }
         return Math.min(F(arr,L+1,R),F(arr,L,R-1));
     }
     ```

     

   #####   5.只利用递归函数进行栈的逆序

   - 1.需要完成将栈的最底部数 掏出不改变其他的数字 返回并且删除

   - 2.利用上面的方式 将所有弹出的数字存储(系统栈即可) 当栈空之后全部压入即可

     ```java
     public static int f(Stack<Integer> stack){
             int result = stack.pop();
             if (stack.isEmpty()) {
                 return result;
             }else{
                 int last = f(stack);
                 stack.push(result);
                 return last;
             }
         }
         public static void reverse(Stack<Integer> stack){
             if (stack.isEmpty()) {
                 return;
             }
             int i = f(stack);
             reverse(stack);
             stack.push(i);
         }
     ```

     

   ##### 6.数字以及组合转换的问题对应的字母问题 - 返回的是所有的情况

   - 1.暴力递归？ 从左往右明显

   - 2.BaseCase 当刚好到最后一个长度的时候 直接返回一种情况 如果数字是0的话 那么此处情况往后都是不能组合的/  如何是1的话？ 两种情况随意组合(本身+ 本身+下一个) 如果是2的话？ - 两种情况(本身+ 本身+下一个(必须在6以内)) 其余的就只能是自身转换

   - 3.normalCase 上面已经包含了

     ```java
     public static int process(char[] str, int i){
         if(i == str.length){
             return 1;
         }
         if(i == 0){
             return 0;
         }
         if(i == 1){
             int res = process(str,i+1);
                 if (i+1 < str.length) {
                     //两两组合的情况
                     res += process2(str,i+2);
                 }
                 return res;
         }
         if(i == 2){
             int res = process(str,i+1);
              if(i +1<str.length && str[i+1] >= '0' && str[i+1] <= '6'){
                     res += process(str, i+2);
                 }
                 return res;
         }
         return process(str,i+1); //此处是>2 因此只能自己本身进行转换
     }
     ```

     

   ##### 7.背包问题 - 一个背包可以承载K的重量 一个袋子(内部有values 以及自己对应的重量) 要求K承载最大的value

   - 1.暴力递归？ - 明显是从左往右

   - 2.BaseCase？ - 背包已经的重量:是否比能够承受的多？ 是否此时相等？

   - 3.normalCase? - 不背这个袋子 or 背 -- 两者最大

     ```java
     public static int maxBag(int[] weight, int[] values, int i, int alreadyWeight, int bag){
             if (alreadyWeight > bag) {
                 return -values[i-1];
             }
             if (alreadyWeight == bag) {
                 return 0;
             }
             return Math.max(maxBag(weight,values,i+1,alreadyWeight,bag),
                     values[i] + maxBag(weight,values,i+1,alreadyWeight+weight[i],bag));
         }
     
     //一定要理解你的边界条件 返回的是什么？ 是个数？？？ 还是说是利润？(return 可能不同)
     ```


8.**超级洗衣机问题：**

```java
/*
问题描述： 每一台洗衣机可以同时一次向旁边的洗衣机抛出衣服 要求就是使所有的洗衣机洗衣服的件数一样 但是所使用最小的交换次数

想法根据剩余需要的件数进行思考： 
1.最基本的大过滤器就是：总衣服的件数 和洗衣机的数量进行取余 如果有余数则肯定不能够完成
2.如果左边和右边都是负数(表示不足平均) -- 则说明只能将当前洗衣机(arr[i])往两边扔 因为一次性只能够扔1件所以最少的次数都是：两者相加
3.如果左边或者右边有一边是正数的话： 明显是两者绝对值的最大值 是需要的最少可能实现的次数
4.如果两边都是正数的话： 同理两边可以像当前的洗衣机进行仍衣服 因此还是Math.max()两边
5.实现的话 应该是每一台洗衣机实现的 最大值中再取最大值作为返回的最终条件
*/
public static 
```









## 3. 窗口内最大值最小值更新结构

- 明确滑动窗口这个结构是要满足什么东西 ：窗口维护内找到要找到最大最小值的代价最低

双端队列：











## 4. 二叉树相关问题 - BinaryTree Problems

| 二叉树的一些基本概念和分类                                   | 存储方式                                                     |      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| 平衡二叉搜索树: -在实际上的运用也是很广泛的例如 map set MutiMap等都是使用平衡二叉搜索树- 因此对应的本身的性质就是key的排序都是有顺序的(搜索以及添加的时间复杂度都是logN级别的) | 1.采用顺序存储方式来保存二叉树：虽然平时很少运用此种方法来保存二叉树但是在 堆的应用中就是使用这种方式(对应要注意的就是左右孩子节点和父节点下标一些相关的问题) |      |
| 如何真正的分清前中后序遍历-中左右 左中右 右左中              | 所代表的是子树的遍历方式-这句话需要重点理解                  |      |
| 所谓深度优先搜索/广度优先搜索                                |                                                              |      |



- 二叉树的遍历示例 以及对应的非递归代码的实现 ----- 下图为中序遍历(左中右-对于每一颗子树而言- 谁是最左且满足左中右？)

  ![image-20210723142218258](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210723142218258.png)



### 1.前中后序遍历-非递归

```java

Static class Node{
	int value;
    Node next;
    public Node(int value){
        this.value = value;
    }
}


//前序遍历: Stack压入 弹出就打印 加右加左
public static void preNonRecursion(Node head){
    if(head != null){
        Stack<Node> stack = new Stack<>();
        stack.push(head);
        while(!stack.isEmpty()){
            head =  stack.pop();
            sout--
            if(head.right != null){
                stack.push(head.right);
            }
            if(head.left != null){
                stack.push(head.left);
            }
        }
    }
}
//后序遍历: 双栈s1 s2 弹出就压入s2 最后将s2全部弹出并且打印
public static void PosOrderUnRecur(Node head){
        // 1 2 3
        if (head != null) {
            Stack<Node> s1 = new Stack<>();
            Stack<Node> s2 = new Stack<>();
            s1.push(head);
            while(!s1.isEmpty()){
                head = s1.pop();
                s2.push(head);
                if (head.left != null) {
                    s1.push(head.left);
                }
                if (head.right != null){
                    s1.push(head.right);
                }
            }
            while (!s2.isEmpty()) {
                System.out.println(s2.pop().value+" ");
            }
        }
        System.out.println(" ");
    }

//中序遍历 - 单栈stack 将左边全部压入先 如果左子为空弹出打印压右
public static void inOrderUnRecur(Node head){
    if(head != null){
        Stack<Node> stack = new Stack<>();
        while(!stack.isEmpty() || head != null){
            if(head != null){
                stack.push(head);
                head = head.left;
            }else{
                head = stack.pop();
                sout ---;
                head = head.right;
            }
        }
    }
}
```

### 2.宽度优先遍历 - 最大宽度

```java
//单队列参考先序  先压左再右
public static void widthNoRecur(Node head){
        if (head == null) {
            return;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.add(head);
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur.value);
            if (cur.left != null) {
                queue.add(cur.left);
            }
            if (cur.right != null) {
                queue.add(cur.right);
            }
        }
    }

//最大宽度问题: HashMap记录对应点和层数 - 宽度优先遍历 不是同层就结算
public static void w(Node head){
    if(head == null){
        return head;
    }
    Queue<Node> queue = new Queue<>();
    HashMap<Node,Integer> map = new HashMap<>();
    int curLevel = 1;
    int curLevelNodes = 0;
    int max = Integer.MIN_VALUE;
    map.put(head,curLevel);
    queue.add(head);
    while(!queue.isEmpty()){
        head = queue.poll();
        int curNodesLevel = map.get(head);
        
        //结算
        if(curLevel != curNodesLevel){
            max = max >= curLevelNodes ? max : curLevelNodes;
            curLevelNodes = 1;
            curLevel++;
        }else{
            curLevelNodes++;
        }
        
       
        if(head.left != null){
                map.put(head.left, curNodesLevle+1);
                queue.add(head.left);
         }
         if(head.right != null){
                map.put(head.right, curNodesLevle+1);
                queue.add(head.right);
          }
        
    }
}









//实际上需要关注层序遍历的两种遍历方法 -1.一次性遍历完本层 2.或者像上面一样
//下面的习题都是在一个模板的基础上： 对层序遍历的具体时间点进行处理的出来的答案结果

//1.二叉树的最大深度
    public static int getMaxDepth(Node head){
        if (head == null) {
            return 0;
        }
        int left = getMaxDepth(head.left);
        int right = getMaxDepth(head.right);
        return  Math.max(left,right)+1;
    }
    //非递归 层序遍历但是需要一次性遍历完成
    public static int getMaxDepth1(Node head){
        if (head != null) {
            Queue<Node> queue = new LinkedList<>();
            int depth = 0;
            queue.add(head);
            while(!queue.isEmpty()){
                int size = queue.size();
                depth++;
                //一次性将本层的所有点弹出 但是添加的同时加入对应的节点
                for (int i = 0; i < size; i++) {
                    Node cur = queue.peek();
                    queue.poll();
                    if (cur.left!=null) {
                        queue.add(cur.left);
                    }
                    if(cur.right != null){
                        queue.add(cur.right);
                    }
                }
            }
            return depth;
        }
        return 0;
    }


    //层序遍历
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root != null) {
            List<List<Integer>> levelList = new ArrayList<>();
            List<Integer> list = new ArrayList<>();
            Queue<TreeNode> queue = new LinkedList<>();
            queue.add(root);
            while(!queue.isEmpty()){
                int size = queue.size();
                for (int i = 0; i < size ; i++) {
                    TreeNode cur = queue.poll();
                    list.add(cur.val);
                    if (cur.left != null) {
                        queue.add(cur.left);
                    }
                    if (cur.right != null) {
                        queue.add(cur.right);
                    }
                }
                levelList.add(list);
                list = new ArrayList<>();
            }
            //Collections.reverse(list); -对应107题 层序遍历2(需要从下往上 从右往左)
            return levelList;
        }
        return new ArrayList<>();
    }


    //二叉树的右侧视图
    public List<Integer> rightSideView(TreeNode root) {
        if (root != null) {
            Queue<TreeNode> queue = new LinkedList<>();
            queue.add(root);
            List<Integer> list = new ArrayList<>();
            while(!queue.isEmpty()){
                int size = queue.size();
                //一次性将本层的所有点弹出 但是添加的同时加入对应的节点
                for (int i = 0; i < size; i++) {
                    TreeNode cur =  queue.poll();
                    if (i == size-1) {
                        list.add(cur.val);
                    }
                    if (cur.left!=null) {
                        queue.add(cur.left);
                    }
                    if(cur.right != null){
                        queue.add(cur.right);
                    }
                }
            }
            return list;
        }
        return new ArrayList<>();
    }



//二叉树每一层的平均值
    public List<Double> averageOfLevels(TreeNode root) {
        if (root != null) {
            Queue<TreeNode> queue = new LinkedList<>();
            queue.add(root);
            List<Double> list = new ArrayList<>();
            double sum = 0;
            while(!queue.isEmpty()){
                int size = queue.size();
                //一次性将本层的所有点弹出 但是添加的同时加入对应的节点
                for (int i = 0; i < size; i++) {
                    TreeNode cur = queue.poll();
                    sum += cur.val;
                    if (size-1 == i) {
                        sum = sum/size;
                        list.add(sum);
                    }
                    if (cur.left!=null) {
                        queue.add(cur.left);
                    }
                    if(cur.right != null){
                        queue.add(cur.right);
                    }
                }
                sum = 0;
            }
            return list;
        }
        return new ArrayList<>();
    }

    //N叉树的层序遍历 -- 无非就是将左右节点变成了使用数组装载的子节点
    public List<List<Integer>> levelOrder(Node2 root) {
        if (root != null) {
            Queue<Node2> queue = new LinkedList<>();
            queue.add(root);
            List<List<Integer>> levelList = new ArrayList<>();
            List<Integer> list = new ArrayList<>();
            while (!queue.isEmpty()) {
                int size = queue.size();
                for (int i = 0; i < size; i++) {
                    Node2 cur = queue.poll();
                    list.add(cur.val);
                    for (int j = 0; j < cur.children.size() ; j++) {
                        if (cur.children.get(j) != null) {
                            queue.add(cur.children.get(j));
                        }
                    }
                }
                levelList.add(list);
                list = new ArrayList<>();
            }
            return levelList;
        }
        return new ArrayList<>();
    }




    //树的每一行找到最大值
    public List<Integer> largestValues(TreeNode root) {
        if (root != null) {
            Queue<TreeNode> queue = new LinkedList<>();
            queue.add(root);
            List<Integer> list = new ArrayList<>();
            Integer sum = Integer.MIN_VALUE;
            while(!queue.isEmpty()){
                int size = queue.size();
                //一次性将本层的所有点弹出 但是添加的同时加入对应的节点
                for (int i = 0; i < size; i++) {
                    TreeNode cur = queue.poll();
                    sum = sum > cur.val ? sum : cur.val;
                    if (cur.left!=null) {
                        queue.add(cur.left);
                    }
                    if(cur.right != null){
                        queue.add(cur.right);
                    }
                }
                list.add(sum);
                sum = Integer.MIN_VALUE;
            }
            return list;
        }
        return new ArrayList<>();
    }







    //填充每个节点的next节点(一个next指针指向自己的右边界点)
    public Node connect(Node root) {
        if (root != null) {
            Queue<Node> queue = new LinkedList<>();
            queue.add(root);
            while(!queue.isEmpty()){
                int size = queue.size();
                Node pre = null;
                Node cur = null;
                //一次性将本层的所有点弹出 但是添加的同时加入对应的节点
                for (int i = 0; i < size; i++) {
                    if (i == 0) {
                        pre = queue.poll();
                        cur = pre;
                    }else {
                        cur = queue.poll();
                        pre.next = cur;
                        pre = pre.next;
                    }
                    if (cur.left!=null) {
                        queue.add(cur.left);
                    }
                    if(cur.right != null){
                        queue.add(cur.right);
                    }
                }
                pre.next = null;
            }
            return root;
        }
        return null;
    }

    //递归版本
    public Node connect1(Node root) {
        if (root == null) {
            return null;
        }
        if (root.left != null) {
            root.left.next = root.right;
            if (root.next != null) {
                root.right.next = root.next.left;
            }
        }
        connect1(root.left);
        connect1(root.right);
        return root;
    }



 //N叉树的最大深度
    public static int maxDepth(Node2 root) {
        if (root == null) {
            return 0;
        }
        int depth = 0;
        for (int i = 0; i < root.children.size(); i++) {
            depth = Math.max(depth,maxDepth(root.children.get(i)));
        }
        return depth+1;
    }
    //非递归的方法
    public static int maxDepth1(Node2 root){
        if (root != null) {
            Queue<Node2> queue = new LinkedList<>();
            queue.add(root);
            int depth = 0;
            while (!queue.isEmpty()) {
                int size = queue.size();
                for (int i = 0; i < size ; i++) {
                    if (i == size-1) {
                        depth++;
                    }
                    Node2 cur = queue.poll();
                    for (int i1 = 0; i1 < cur.children.size(); i1++) {
                        if (cur.children.get(i1) != null) {
                            queue.add(cur.children.get(i1));
                        }
                    }
                }
            }
            return depth;
        }
        return 0;
    }

    //二叉树的最小深度 -区分基本概念： 区别在于最小深度是：第一个没有左右子孩子的节点所在的位置
    //1.如果左边没有子树的话： 应当返回右子树+1 右子树同理 2.如果左子树都有的话 就是两者最小的+1
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        if(left == 0 && right != 0){
            return right+1;
        }else if(left != 0 && right == 0){
            return left+1;
        }
        return Math.min(left,right)+1;
    }











```



### 3.判断是否为搜索二叉树 完全二叉树 满二叉树 平衡二叉树+ 树型DP解法

```java
//1.搜索二叉树？ - 基本Recursion - 左右子树是否为搜索二叉树？ 左右中节点的值是否符合搜索二叉树的性质

public static int preValue = Integer.MIN_VALUE;
//因为本身就是满足左中右的顺序 递归的话考虑单次情况即可
//当前节点是！！！ 该树的根节点(返回的是左子节点的值)
public static boolean isBST(Node head){
    if(head == null){
        return true;
    }
    boolean left = isBST(head.left);
    if(!left){
        return false;
    }
    if(head.value <= preValue){
            return false;
        } else {
          preValue = head.value;
        }
    return isBST(head.right);
}

//2.傻白甜方法
public static boolean isBST1(Node head){
        if (head == null) {
            return true;
        }
        ArrayList<Node> list = new ArrayList<>();
        process(head,list);
        for (int i = 1; i < list.size(); i++) {
            if (list.get(i-1).value > list.get(i).value) {
                return false;
            }
        }
        return true;
    }
    public static void process(Node head, ArrayList<Node> list){
        if (head == null) {
            return;
        }
        process(head.left,list);
        list.add(head);
        process(head.right,list);
    }


//3.非递归中序遍历解决
    public static boolean isBST2(Node head){
        if (head != null) {
            int preValue = Integer.MIN_VALUE;
            Stack<Node> stack = new Stack<>();
            while (!stack.isEmpty() || head != null){
                if (head!= null) {
                    stack.push(head);
                    head = head.left;
                }else {
                    //弹出就结算 -- 满足搜索二叉树判断即可
                    head= stack.pop();
                    
                    //打印部分完成业务即可
                    if (head.value <= preValue) {
                        return false;
                    }else {
                        preValue = head.value;
                    }
                    
                    
                    
                    
                    
                    head = head.right;
                }
            }
        }
        return  true;
    }

//4.二叉树两个节点最近的两个任意节点的问题 -- 本质问题: 
//1.两个节点的最大长度在子树中 不需要经过自身节点x
//2.两个最长的距离节点需要经过自身节点x -- 意思就是左右两棵子树进行获取
//3.节点的距离就可以等价为对应的高度
//4.因此本质的问题就是: 左子树的最大长度Length 右子树的最大长度  以及两者的高度+1 中的最大值获取
//树型DP套路，解决子树两点的最大长度问题
    public static int getBigestDistance(Node head){
        if (head == null) {
            return 0;
        }
        return getProcess(head).length;
    }
    public static class ReturnType4{
        int length;
        int height;
        public ReturnType4(int length, int height){
            this.length = length;
            this.height = height;
        }
    }
    public static ReturnType4 getProcess(Node head){
        if (head == null) {
            return new ReturnType4(0,0);
        }
        ReturnType4 left = getProcess(head.left);
        ReturnType4 right = getProcess(head.right);
        int length = Math.max(left.length,right.length);
        int p1 = left.height + 1 + right.height;        //根据分类的情况 并不是和本树的高度进行比较 而是和两棵子树高度+自身(构成的最大距离)
        int height = Math.max(left.height,right.height)+1;
        return new ReturnType4(Math.max(p1,length),height);
    }


//5.树型Dp问题当涉及到了多叉树 -- 其实本质也是没有变化 找出来具体可能的所有情况
//但是对于多叉树的问题 涉及到了一种应该如何去遍历下级的方法-这里指的是编程细节方面
//利用的就是list<Node>列表的形式 来记录下层的节点 遍历其实就是列表的遍历

```



### 4.多叉树问题 - 派对的最大快乐值

```java
//但是对于多叉树的问题 涉及到了一种应该如何去遍历下级的方法-这里指的是编程细节方面
//利用的就是list<Node>列表的形式 来记录下层的节点 遍历其实就是列表的遍历
class Employee{
    int happy; //本身快乐值
    List<Employee> next; //下级员工列表
}
public static class Info{
    int buMaxHappy;
   	int laiMaxHappy;
    public Info(int bu, int lai){
        buMaxHappy = bu;
        laiMaxHappy = lai;
    }
} 
public static Info process(Employee x){
    if(x == null){
        return new Info(0,x.happy);
    }
    //返回的是记录一个点的最大最小 所以整个是一个迭代的过程
    int lai = x.value; //表示本次来还是不来
    int bu = 0;
    for(Employee next : x.next){
        Info nextInfo = process(next);
        bu += Math.max(nextInfo.lai,nextInfo.bu);
        lai += nextInfo.bu;
    }
    return new Info(bu,lai);
}

```

### 5.Morris遍历相关的问题 

```java
//不涉及到第三方的一个信息强整合问题采用Morris遍历
//1.当前的cur节点判断是否有左孩子？ -- 没有直接向右移动cur = cur.right;
//2.如果有左孩子： 找到左子树上最右边的节点mostRight a:如果mostRight右指针为空 指向cur然后cur=cur.left左移动
//b:如果mostRight右指针指向cur - mostright指向null cur向右边移动
//3.cur为空的时候 停止遍历
 public static void morris(Node head){
        if (head != null) {
            Node cur = head;
            while(cur != null){
                System.out.print(cur.value+" ");
                if (cur.left == null) {
                    cur = cur.right;
                }else {
                    Node mostRight = cur.left;
                    while (mostRight.right!=null && mostRight.right != cur){
                        mostRight = mostRight.right;
                    }
                    if(mostRight.right == null){
                        mostRight.right = cur;
                        cur = cur.left;
                    }else if(mostRight.right == cur){
                        mostRight.right = null;
                        cur = cur.right;
                    }
                }
            }
        }
    }

//1.Morris遍历改造前序遍历 -- 只能来到一次的话直接打印 第二次来到的话第一次直接打印
//morris -先序遍历 能到达两次只是第一次打印 只能一次的话直接打印
    public static void morrisPre(Node head){
        if (head != null) {
            Node cur = head;
            Node mostRight = null;
            while(cur != null){
                mostRight = cur.left;
                if (mostRight != null) {
                    while (mostRight.right!=null && mostRight.right != cur) {
                        mostRight = mostRight.right;
                    }
                    if(mostRight.right == null){
                        System.out.println(cur.value);
                        mostRight.right = cur;
                        cur = cur.left;
                        continue;
                    }else if(mostRight.right == cur){
                        mostRight.right = null;
                    }
                }else {
                    System.out.println(cur.value);
                }
                cur = cur.right;
            }
        }
    }
//morris中序遍历 - 只能来到当前节点一次的话直接进行打印     有两次的第二次进行打印
    public static void morrisIn(Node head){
        if (head != null) {
            Node cur = head;
            Node mostRight = null;
            while(cur != null){
                mostRight = cur.left;
                if (mostRight != null) {
                    while (mostRight.right!=null && mostRight.right != cur) {
                        mostRight = mostRight.right;
                    }
                    if(mostRight.right == null){
                        mostRight.right = cur;
                        cur = cur.left;
                        continue;
                    }else if(mostRight.right == cur){
                        System.out.println(cur.value); //来到当前节点的第二次
                        mostRight.right = null;
                    }
                }else {
                    System.out.println(cur.value);
                }
                cur = cur.right;
            }
        }
    }

    //Morris遍历的后序遍历 - 第二次开始到达节点
    /*打印该节点左子树进行逆序打印  打印完之后逆序打印整棵树节点
    *
    * */
    public static void morrisPost(Node head){
        if (head != null) {
            Node cur = head;
            Node mostRight = null;
            while(cur != null){
                mostRight = cur.left;
                if (mostRight != null) {
                    while (mostRight.right!=null && mostRight.right != cur) {
                        mostRight = mostRight.right;
                    }
                    if(mostRight.right == null){
                        mostRight.right = cur;
                        cur = cur.left;
                        continue;
                    }else if(mostRight.right == cur){
                        mostRight.right = null;
                        printEdge(cur.left);
                    }
                }
                cur = cur.right;
            }
            printEdge(head);
            System.out.println(" ");
        }
    }
    public static void printEdge(Node x){
        Node tail = reverseEdge(x);
        Node cur = tail;
        while (cur != null) {
            System.out.println(cur.value +" ");
            cur = cur.right;
        }
        reverseEdge(tail);
    }

    private static Node reverseEdge(Node from) {
        Node pre = null;
        Node next = null;
        while(from != null){
            next = from.right;
            from.right = pre;
            pre = from;
            from = next;
        }
        return pre;
    }

```





是否需要第三次进行信息的强整合

![image-20210728171306982](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210728171306982.png)

![image-20210724192401061](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210724192401061.png

![image-20210724192445448](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210724192445448.png)

![image-20210724192613429](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210724192613429.png)













































### 6.二叉树构造的类似问题

```java
//反转二叉树
    public static TreeNode reverseBinaryTree(TreeNode head){
        if (head == null) {
            return head;
        }
        reverseBinaryTree(head.left);
        swap(head.left,head.right);
        reverseBinaryTree(head.right);
        return head;
    }

    private static void swap(TreeNode left, TreeNode right) {
        TreeNode temp = left;
        left = right;
        right =temp;
    }
    public static void print(TreeNode head){
        if (head == null) {
            return;
        }
        System.out.print(head.val+" ");
        reverseBinaryTree(head.left);
        reverseBinaryTree(head.right);
    }

    //判断二叉树是否对称
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return compare(root.left,root.right);
    }
    public static boolean compare(TreeNode left, TreeNode right){
        if(left == null && right != null){
            return false;
        }
        else if(left != null && right == null){
            return false;
        }else if (left == null && right == null){
            return true;
        }else if(left.val != right.val){
            return false;
        }
        boolean outSide = compare(left.left,right.right);
        boolean inSide = compare(left.right,right.left);
        return  outSide&&inSide;
    }

```

```t
二叉树的应用:
1.BST - BST不可存在相同的元素
 包含BST查值 BST插入节点 BST的构造
 
2.叶节点的带权路径长度
叶节点到根节点的距离(高度)*weight即可 -- 层序遍历并且外加HashMap记录对应节点的高度

3.相同的数值不同位置构造二叉排序树的时候 是完全不一样的 如果有顺序的话-甚至构造出单链表形式
```

![image-20210821011518442](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210821011518442.png)









### 7.关于背包问题的一些基本的理论

```te
1. 0-1背包问题
要求的是需要不超过背包容量的情况下 能够装最多价值的一种情况
dp数组的含义dp[j]表示在遍历到第i个背包的时候 容量在j情况下最多的价值

1.如果是进行初始化的话: dp[0]的含义为: 装入0的价值则明显就是0

2.遍历的内外循环的顺序问题: 由于既不是要求组合数 也不是要求排列数因此循环的顺序是什么并不重要 习惯上遍历背包数优先-- 但是内层循环遍历顺序因为是背包内重量 因此需要保证背包的承受重量只能是由大到小进行遍历 这样最多只能够将本次背包的价值装入

3.dp[j]取决于: dp[j]-此时是在i-1情况下 以及dp[j-weight[i]]+values[i]-意思就是采用本次背包的价值

4.最终返回: dp[W]即可


2.完全背包问题
对比于0-1背包而言 完全背包就是可以取多次本次的物品
因此内层循环关于承受量 应该从小到大进行装载

3.关于组合数
这就是涉及到总共实现的方法有多少种 而不是最大的一种可能性
则递推关系式易得: dp[j] += dp[j-weights[i]]
此处的dp[j]其实是i-1时候已经包含的所有个数 加上本次如果装入的话能够容纳的最大值
涉及到组合数的话： 关键是前后两种推导都属于一种关系式 因此遍历的顺序只能够是先背包后价值

4.排列数
同组合数不同就是体现在如此： 因为排列数是记载1.5 和 5.1两种情况 因此进行遍历的过程中因当时先遍历values[i]再遍历背包
```





















## 5. 字符串操作相关的

![image-20210724192735647](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210724192735647.png)

```java
public static int needParenteses(String str){
    int count = 0;
    int ans = 0; //规避左括号为0的时候 直接遇见右边括号
    for(int i=0; i < str.length(); i++){
        if(str.charAt(i) == '('){
            count++;
        }else{
            if(count == 0){
                ans++;
            }else{
                count--;
            }
        }
    }
    re
    
}
```









## 6.各种排序算法以及排序算法的比较

###    1. MergeSorting - 归并排序

```java
/*
L -> mid  mid+1 -> R -->再外排
*/


public static void mergeSorting(int[] arr, int L, int R){
	 if(L == R){
          return;
     }
    
    int mid = L+((R-L)>>2);
    mergeSorting(arr,L,mid);
    mergeSorting(arr,mid+1,R);
    merge(arr,L,R,mid);
}

public static void merge(int[] arr, int L, int R, int mid){
    //辅助数组 R-L+1 --基本的长度计算
    int[] help = new int[R-L+1];
    int p1 = L;
    int p2 = mid+1;
    int i = 0;
    while(p1<=mid && p2<=R){
        help[i++] = arr[p1] > arr[p2] ? arr[p1++] : arr[p2++]; 
    }
   	while(p1 <= mid){
        help[i++] = arr[p1++];
    }
    while(p2 <= R){
        help[i++] = arr[p2++];
    }
    for(int i=0; i<help.length; i++){
        arr[L+i] = help[i];
    }
}

```



### 2. QuickSorting - 快排

```java
/*
plus - 荷兰国旗问题
1.注意临界条件
2.玩概率 - 同最后一个数字进行交换作为中间分配的数字
3.每次都找到相等部分的两个小标
4.递归快排一起分配两边
*/
public static void quickSorting(int[] arr, int L, int R){
    if(L > R){
        return;
    }
    swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
    int[] res = partition(arr, L, R);
    quickSorting(arr, L, res[0] - 1);
    quickSorting(arr, res[1] + 1, R);
    
}
public static int[] partition(int[] arr, int L, int R){
    int less = L-1;
    int more = R;
    //1.小的话 less++ L++  2.相等的话L++ 3.大的话同more进行交换More--
    while (L < more) {
            if (arr[L] < arr[R]) {
                swap(arr, ++less, L++);
            } else if (arr[L] == arr[R]) {
                L++;
            } else {
                swap(arr, L, --more);
            }
        }
        swap(arr, L, R);
        return new int[]{less + 1, more};
}


public static void swap(int[] arr, int a, int b){
    int temp =  arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```



### 3. HeapSorting-堆排序

```java
public static void heapSort(int[] arr){
    if(arr = null || arr.length<2){
        return;
    }
    for(int i=0; i<arr.length; i++){
        heapinsert(arr,i); //第一次形成一个大根堆
    }
    int size = arr.length; //以最后一个位置为界限进行划分
    while (size > 0) {
            heapify(arr, 0, size);
            swap(arr, 0, --size);
        }
}
private static void heapinsert(int[] arr, int index) {
        while (arr[index] > arr[(index - 1) / 2]) {
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }
    
 private static void heapify(int[] arr, int index, int heapSize) {
        int left = index * 2 + 1;
        while (left < heapSize) {
            int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[index] ? largest : index;
            if (largest == index) {
                break;
            }
            swap(arr, largest, index);
            index = largest; //外层通过多个while从最底下开始掏(但是你遍历是往下遍历)
            left = index * 2 + 1;
        }
    }
}
```



## 7.栈和队列相关:

```tex
1.实现双端队列采用方法: Java中规定了Deque接口来实现对应方法，其中有
ArrayDeque以及Linkedlist两个实现类完成对应功能使用
两者地区别: ArrayDeque内部是初始化16位长度的数组 因此对于数据量比较少的话 优先采用数据
Linkedlist内部采用的是链式的节点进行存储 - 因此在删除添加方面更加优秀 - 适用于大数据量的形式

2.双端队列的一些使用场景: 
滑动窗口的使用:

逆波兰表达式的使用: 其中特别要注意: 由于先两个数字弹出计算之后再压入 因此对于-和/而言必须是(先前压入)在前面
换句话: 减法时候 弹出的第一个必须为负数  除法时候同理
```

```java
//逆波兰表达式的实现:
/*
1.用途就是将后缀表达式进行求值
2.具体的操作方法: 1.遇见数字压入栈中 2.遇见表达式弹出栈中两个元素进行运算再压入 3.最后弹出最后一个元素返回
*/
 public static int ReversePolishNotation(String[] tokens){
        //只存在 + - * /
        Stack<Integer> stack = new Stack<>();
        for (String s : tokens) {
            if (!isNum(s)) {
                stack.push(convert(s));
            }else if(s.equals("+")){
                stack.push(stack.pop()+stack.pop());
            }
            else if(s.equals("-")){
                stack.push(-stack.pop()+stack.pop());
            }
            else if(s.equals("*")){
                stack.push(stack.pop()*stack.pop());
            }else {
                int num1 = stack.pop();
                int num2 = stack.pop();
                stack.push(num2/num1);
            }
        }
        return stack.pop();
    }
    //判断是否为数字的方法
    public static boolean isNum(String s){
        return s.length() == 1 &&  s.charAt(0) < '0' || s.charAt(0) > '9';
    }
    //将String转换成为数字
    public static int convert(String s){
        return Integer.parseInt(s);
    }
```



## 8.一些容器的基本性质总结

```tex
Vector,HashTable,concurrentHashMap,copyonwriteArrayList是线程安全的。

HashTable以及HashMap的一些对比：
第一，继承不同。Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。

第二，Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，hashtable的实现方法里面添加了synchronized关键字来确保线程同步，但是要使用HashMap的话就要自己增加同步处理了

第三，Hashtable中，key和value都不允许出现Null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该键，也可以表示该键所对应的值为null。因此在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containskey()方法来判断。

第四，两个遍历方式的内部实现上不同。HashTable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式，另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而hashtable的Enumeration迭代器不是fail-fast的。

第五，哈希值的使用不同，HashTable直接使用对象的hashcode。而HashMap重新计算hash值。

第六，hashtable 和hashmap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2 +1,HashMap中hash数组的默认大小是16，而且一定是2的指数。

第七，Hashtable在求数组下标是通过除以length取余，而hashmap是与length-1进行与运算。




Collection接口继承树
-TreeSet And EnumSet
```

![image-20210820010643433](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20210820010643433.png)

---

###### 算法刷题和总结:

#### Algorithm

1.绳子覆盖点问题

```tex
1.给定一个有序数组arr 代表数轴上从左到右n个点
  arr[0]...arr[n-1]给定一个正数L 代表一根长度为L
  的绳子 求绳子最多能覆盖其中的点
  
  solution:将绳子从左到右固定 每次都覆盖其左边所有的点
  整个数组迭代查询之后 得到的最多的结果即是
  -本质一个小的贪心策略/因为你的点可以在很多位置 但是
  你使用以一个存在覆盖点的地方作为起点的话 其实是最有效
  
  算法原型: 在有序区域内找到大于等于某个数最左的位置
  (可以采用二分)
  如图所示数轴/0-5表示数组arr的小标
  对应的2/4/8代表的是点所在的位置
  
  时间复杂度:
  1.搜寻了几个点？ n 2.每个点干了什么事情？-二分
  n*logN
```

![image-20220211213217177](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220211213217177.png)

```tex
solution2: 滑动窗口
L-绳子的长度固定为一个窗口 
从左往右开始 以最左边进行固定往下移动下一个点
判断起始点到当前点的距离 是否超过窗口的大小进行更新
```

```java
//Code
//1.在arr[0..R]范围上 找满足>=value的最左边位置
    public static int nearestIndex(int[] arr, int R, int value){
        //采用迭代方法二分法
        int left = 0;
        int index = R;
        while(left <= R){
            int mid = left + (R-left)>>1;
            if(arr[mid] >= value){
                index = mid;
                R = mid-1;
            }else{
                left= mid+1;
            }
        }
        return index;
    }
    public static int maxPoint(int[] arr, int L){
        int res = 1;
        for (int i = 0; i <arr.length ; i++) {
            int nearest = nearestIndex(arr,i,arr[i]-L);
            res = Math.max(res,i-nearest+1);
        }
        return res;
    }
```



2.奸商打包买苹果问题

```tex
2.小虎去附近的商店买苹果 奸商使用了捆绑交易 只提供6个和8个每一个袋子包装不可以拆分 可是小虎现在恰好要买n个苹果
小虎想要购买尽量少的袋子数量分装 输入一个n 表示小虎购买
苹果个数 返回最小袋子/如果不能装下返回-1
```

```java
//solution1 - 先全部用8来装 再用6类型的袋子试
public static int pickUp(int n){
        if (n%8 == 0) {
            return n/8;
        }
        int R = n/8;
        for (int i = R; i >=0 ; i--) {
            int remain = n-(i*8);
            if(remain%6 == 0){
                return i+(n-i*8)/6;
            }
        }
        return -1;
    }
```

```tex
solution2: 一个业务题入参是一个整数 出参也是一个整数
得出的答案可以采用一般的方法来看答案/所谓的打表法
```

![image-20220212100747274](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220212100747274.png)





3.牛羊吃草

```tex
3.有先手和后手两只动物吃草 每一动物只能吃4的某次方份
  草/给定一个总数份草 返回谁先吃完谁赢
  1.4的倍数应该就有- 1和4这两个起始的吃的状态
    因此可以判断当吃的草总份数在<5情况下可以直接
    穷举得出对应的答案
  2.判断胜利的逻辑:(n>=5) 
    在先手稳定先吃4的倍数的时候 判断后手是否胜利
    因为子过程后手胜利的话 那么应该先手胜利
    
    注意: 此处有一个防止越过整数的最大边界max
    因此在while(base<=n)的基础上判断一个base*4
    的情况 如果大于4之后就没有必要继续往上了
    
  3.Solution2利用打表法
```

```java
 //3.吃草问题 - 4的幂次倍数 先手还是后手胜利
    public static String winner(int n){
        /*
        * 0 - 后  1 - 先  2 - 后  3 - 先  4- 先
        * 有关于0-先手此时面对草 但是已经吃完了
        * */
        if(n < 5){
           if(n<0){ return "错误";}
           return (n==0 || n == 2) ? "后手" : "先手";
        }
        int base = 1; //选择先手吃草的份数
        while(base <= n){
            //剩余的草传入 此时的后手为子函数的先手
            //如果后手获胜 那么即是本函数的先手获胜
            if(winner(n-base).equals("后手")){
                return "先手";
            }
            if(base > n/4){
                break;//防止base越界
            }
            base *= 4;
        }
        return "后手";
    }
```

![image-20220212104946077](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220212104946077.png)

```tex
利用打表法: 后先后先先...
```

```java
public static String winner1(int n){
    if(n%5 == 0 || n%5 == 2){
        return "后手";
    }else{
        return "先手";
    }
}
```



4.预处理结构问题

```tex
//一维的预处理结构

牛牛有一些排成一行的正方形 每个正方形已经被染成了红色或者绿色 牛可以现在任意选择一个正方形然后用这两种颜色任意一种进行染色 这个正方形的颜色将会被覆盖

牛牛的目标是在完成染色之后 每个红色R比每个绿色G距离最左侧近牛牛想知道最少需要濡染几个正方形
样式: s = RGRGR -> RRRGG 染色个数是2

solution1-simplistic version
需要保持一种从左往右不断进行处理-总而言之就是分治的思想
从左到右每次看的是选中部分左边的部分
题目要求的是 左边全部都是R 右边都是G
例子:
Special Case
第一个字母开始 左边并没有对应的情况 因此只需要
处理右边使其右边所有变成G因此则需要统计个数
最后一个字母而言 右边也是没有了 因此只需要统计
左边有多少个R即可
普通Case: 统计左边的G个数和统计右边R的个数需要替换     
```

```java
public static int minPaintTest(String s){
        char[] arr = s.toCharArray();
        int N = arr.length;
        int[] arr1 = new int[N]; //统计以当前下标为arr[i]起始的左边包含G的个数
        int[] arr2 = new int[N];
        int nums = 0;
        int answer = 0;
        //初始化对应的arr 便于判断
        for (int i = 0; i < N ; i++) {
            int begin = 0;
            int begin1 = i+1;//右边是不包含本身的
            arr1[i] = nums;
            arr2[i] = nums;
            while(begin <= i){
                if(arr[begin] == 'G'){
                    arr1[i]++;
                }
                begin++;
            }
            while(begin1 < N){
                if(arr[begin1] == 'R'){
                    arr2[i]++;
                }
                begin1++;
            }
            nums = 0;
        }
        for (int i = 0; i < N; i++) {
            if(i == 0){
                answer = arr2[i];
            }
            if(i == N-1){
                answer = answer > arr1[i] ? arr1[i] : answer;
            }
            nums = arr1[i]+arr2[i];
            answer = answer > nums ? nums : answer;
        }
        return answer;
    }
```

![image-20220212232227048](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220212232227048.png)

```tex
//二维的预处理结构

给定一个N*N的矩阵matrix 只有0和1两种值 返回边框全是1的最大正方形的边长长度
01111
01001
01001
01111
01011 --返回的答案是4*4(4)--边框是1即可满足

solution1：
关键在于如何处理正方形的选择问题 在一个二维数组的区域选择一个唯一的四边形时间复杂度？-是O(n的四次方) 
因为一个四边形确定形状 只需要找到左上角的一个点以及
右下角的一个点/两者选择的概率都是n方的复杂度可能性
因此相乘的话 就是n的四次方复杂度

但是如果选择的是一个正方形的话 时间复杂度又会减少
因为只需要决定左上角的一个点是n平方的时间复杂度
接下来一个循环只需要决定正方形的边长 因此整体
的时间复杂度是n的三次方复杂度

当确定了正方形之后 内部需要完成和实现的就是确定
对应的四条边是否全部是1 - 如果不采用预处理结构
的话就是四个for循环分别检查
最终造成时间复杂度依旧是n的四次方

因此在内部处理的结构利用down和right两个数组
表示当前往右和往下有多少个1的情况
因此我们只需要获得正方形三个点就可以确定三者
构成的边所有满足最多1的情况
```

```java
  //5.正方形边长最多1的情况
    public static int maxAllOneBorder(int[][] m){
        int row = m.length; //行
        int col = m[0].length; //列
        int res = 0;
        int[][] right = new int[row][col];
        int[][] down = new int[row][col];
        //预处理两个right和down matrix(代表该点往右和往下1的个数)-包含本身
        for (int i = 0; i < row ; i++) {
            for (int j = 0; j <col ; j++) {
                int k = j;
                int cur = 0;
                while(k < col){
                    if(m[i][k] == 1){
                        cur++;
                        k++;
                    }else {
                        break;
                    }
                }
                right[i][j] = cur;
            }
        }
        //down数组
        for (int i = 0; i < col ; i++) {
            for (int j = 0; j <row ; j++) {
                int k = j;
                int cur = 0;
                while(k < row){
                    if(m[i][k] == 1){
                        cur++;
                        k++;
                    }else {
                        break;
                    }
                }
                down[i][j] = cur;
            }
        }

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < Math.min(col-j,row-i) ; k++) {
                    //规定了固定的点是正方形左上角的点 因此长度最大的可能情况就是以对应边为边界的情况
                    //利用该点确定能够决定的最大长度
                    int length = Math.min(right[i][j],down[i][j]);
                    if (Math.min(down[i][j+length-1],right[i+length-1][j])>=length) {
                        res = Math.max(res,length);
                    }
                }
            }
        }
        return res;
    }

```

5.计算机二进制来解决等概率返回问题

```tex
6.给定一个函数f 可以1-5数字等概率返回一个 请你=加工出1-7的数字等概率返回一个的函数g
solution1:
 1.如何利用一个等概率得出1-5的函数 来得出等概率返回0和1
  的函数 将3这个结果排除因此只有1-2-4-5分别是两个奇数
  两个偶数 因此就可以概率相同
 2.1-7同理 利用0和1的情况就可以利用二进制组合出
   所有的数字情况进行拼接即可
   
   关键在于拼接二进制位--例如13-21等概率返回
   但是你需要的数字可以理解为0-8的情况 0-8需要的
   二进制位数同理就是4位/不过不好拼接的话可以使用
   res最后在+ -来获得你好拼接的情况
   
   构造0-1等概率的发生器(关键在于分开奇偶即可)
```

```java
//6.获得0和1等概率的情况
    //1-5
    public static int f(){
        return (int) (Math.random()*5)+1;
    }
    //0,1
    public static int r01(){
        int res = 0;
        do {
            res = f();
        }while(f() == 3);
        return (res%2==0) ? 0 : 1;
    }
    //1-7
    public static int r02(){
        int res = 0;
        do {
            //左移是数字左移(相当于*)
            res = (r01()<<2)+(r01()<<1)+r01();
        }while(res == 7);
        return res+1;
    }
```

```tex
给定一个函数以 p概率返回0 1-p概率返回1
构造出等概率的情况的函数: 
solution-利用函数两回即可 返回00和11的情况不需要
只需要返回10或者是01的情况-同样是当作两种情况返回即可
```

6.一般动态规划dp

```tex
7.给定一个非负整数n 代表二叉树的结点个数 返回能形成多少种不同的二叉树结构
```

```tex
8.一个完整的括号字符串规定如下
```















































#### Machine Stupid shit

```c
//输出进制转换
printf("%x\n",a); 小写的十六进制
printf("%X\n",a); 大写的十六进制
printf("%o\n",a); 小写的八进制

//输出增加前置0
int a = 5;
printf("%02d\n", a); //其中2代表宽度 不足的地方用0来填充
print("%04d\n",b); 输出结果 0005

//输出保留小数
double a = 3.6;
printf("%.21f\n", a); //2表示保留两位小数 结果为3.60

C语言沟八算法:
1：基本的if else分层算法
     主要的是浮点数的输入 - 最好就是用lf 即是double
     输出的方式 "pay = %lf", a 即是就是输出如此
     输入的时候 - 如果是一般的变量要使用 地址&a
               -例如char等等或者数组即是 直接使用即可
2：进制的转换 - 通用版
```

![image-20220330110810997](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220330110810997.png)

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220330164129910.png" alt="image-20220330164129910" style="zoom: 50%;" />

```c
//关于矩阵的翻转问题
1:若是一般的反转90°或者180°等等问题
    solution: 都是找到每一个元素之间对应的数组下标关系即可
    exa: 顺时针反转90: 显然列和行对换剩下的和正好为总行数
    123
    456
    789 --- 741
            852
            963
    00 - 02  01 - 12  02 - 22  10 - 01 11 - 11  12-21
2: 180°同理可以采用这种办法获取答案
   -exa: dj1377 就是上述问题的杂糅
    处理好输入将对应输入的两个矩阵存储起来 - 然后分别将原先旋转
    的封装成为一个判断的函数即可

//关于矩阵回字型打印的问题
3: 一定要有整体的思维去思考 可以看成外部回一直往里收缩的过程
    solution: 固定好ar ac br bc分别表示的是左右的行和列
     他们的边界(用于收缩进行总结) 
        - while(ar <= br && ac <= bc)
        -内部重新定义a1 a2 b1 b2进行内部打印的处理
        -做好边界的处理(可能会出现重复打印的情况)
        -ar++ ac++ br-- bc--进入下一个回
            
//关于利用*或者其他字符来堆叠的问题
4:   solution: 无非就是“ ”和字符组成的规律
     若是只有一边三角的情况通常都是好解决的
     若是两边都存在空的情况 - 则需要判断*和" "数量
     的关系 
     下图显示之间的关系就是
     1 3 5 7 对应n的关系即是: 2n-1
     并且可以得出空格的关系((最长部分)2n-1)-2i-1)/2化简即可
         
5: 拓展就是菱形的堆叠问题:(dj1473)
   即是再一次打印相反的和上部分进行重合即可(下半部分需要少一行)
```

![image-20220331224717021](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220331224717021.png)

![image-20220331230945218](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220331230945218.png)

```c
//日期类相关的问题: 
代表就是输入 year month day(并且是结构体的形式)
结构体后面的写出就是其的一个实例(特别牛)
   1:判断是否为闰年(隐含了2.29的判断)
   2:利用数组来对前面的天数进行处理
```

<img src="C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220331232558073.png" alt="image-20220331232558073" style="zoom:67%;" />

![image-20220401011245469](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220401011245469.png)

```c++
//字符串类型的题目
C语言中所有格式化类型的定义：

1、%d/i

接受整数值并将它表示为有符号的十进制整数，i是老式写法

2、%o

无符号8进制整数(不输出前缀0)

3、%u

无符号10进制整数

4、%x/X

无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF(不输出前缀0x)

5、%f(lf)

单精度浮点数和双精度浮点数用f(lf在C99开始加入标准，意思和f相同)

6、%e/E

科学计数法表示的数，此处"e"的大小写代表在输出时用的“e”的大小写

7、%g/G

有效位数，如：%.8g表示单精度浮点数保留8位有效数字。

8、%c

字符型。可以把输入的数字按照ASCII码相应转换为对应的字符

9、%s/S

字符串。输出字符串中的字符直至字符串中的空字符(字符串以'\0‘结尾，这个'\0'即空字符)

10、%p

以16进制形式输出指针

11、%n

//排序类相关的-采用一个sort函数搞定
 sort传入三个函数 -排序区间起点 - 排序区间终点+1 - 比较器
 其中比较器定义的bool类型的即可 - 
 #include <bits/stdc++.h>
using namespace std;

struct Student{
    int score;
    string name;
}stu[1005];

/*
比较器的定义一定要放在前面才可以生效
创建的时候采用c++即可

sort默认采用的是快排 - 因此不稳定
利用stable_sort函数是稳定的排序

第二种方式 就是给结构体定义多一个变量
然后在比较器上进行修改操作 -搞一个二级排序
*/
bool comparetorAsc(Student a1, Student a2){
    return a1.score < a2.score;
}

bool comparetorDesc(Student a1, Student a2){
    return a1.score > a2.score;
}

void sortStudent(int n, int cmp){
    if(cmp == 1){
        stable_sort(stu,stu+n,comparetorAsc);
    }else{
        stable_sort(stu,stu+n,comparetorDesc);
    }
    return;
}

int main()
{
    int n,cmp;
    while(cin >> n){
        cin >> cmp;
        for(int i=0; i<n; i++){
            cin >> stu[i].name>>stu[i].score;
        }
        sortStudent(n,cmp);
        for(int i=0;i<n;i++) {
            cout<<stu[i].name<<" "<<stu[i].score<<endl;
        }
    }
    return 0;
}
```

```c
//关于C使用的问题:
#include<bits/stdc++.h> 万能头文件
多行输入的问题 - 其中EOF是常量的一个类似于输入的缓冲和条件
1:while(scanf("%d%d",&a,&a) != EOF) - 循环读入问题 int a int b
2:上述是int类型的多行输入 如果是字符的多行输入
   char a[105]; gets(a) 然后对a进行遍历即可
//字符串问题 
1：是否采用string? 
2：字符串匹配的基本方式
3：ASCII码相关匹配和变化 - 采用map进行映射
4: map的遍历和排序cmp的用法
 
典型题目: 
 1：删除字符串 - gzu(删除问题首先利用一个新的数组接收 以及下标问题)
    思路: 新数组将全部变为小写的搞定 然后遍历匹配字符串然后标记下标
         将原数组进行打印 有下标的不输出即可
```





```c
//同模定理问题
1: (a+b)%c = (a%c+b%c)%c 
  加法 减法 乘法都是满足于此(但是除法不满足条件) - 除法需要逆元
  (a*b)%c = (a%c*b%c)%c --主要的应用条件就是: 数值太大的情况
```









###### DreamJudg题库

<a href="#1027">1027</a>







###### 数据结构复习:

1：英语口语复习

```java
本科有什么科研经历: 
```



```java
//线性表推广 - 数组以及广义表

1:数据结构的定义:
 数据结构顾名思义就是数据元素不同的存储方式，其中所决定一个数据结构特征的最重要三要素分别是 数据结构的: 逻辑结构 物理存储结构以及该种数据结构所支持的运算操作
其中逻辑结构指的是该数据结构呈现给用户直观层面上的数据展示(例如: 是相邻元素之间是顺序关系 还是不同元素之间是一种集合的关系 或者是树型祖先以及孩子的存储关系)
存储结构所包括的是: 具体在计算机中实现该数据结构数据元素逻辑层面关系的物理存储结构-(例如顺序表可以采用 数组所表示的顺序存储以及采用结点所表示的链式存储两种方式)
数据运算就是数据结构逻辑层面上所支持的对数据的操作方式-如栈它只允许在数据结构的一边进行插入或者删除的操作
//数据结构是相互之间的关系成为结构 相互之间存在一种或多种特定关系的数据元素的集合
2：逻辑结构类型
 逻辑结构的类型主要包括有: 集合 线性顺序 树形结构 图状结构
 //大体上分为线性结构和非线性结构两种
     
3：存储结构类型://分清楚索引存储和散列存储之间的区别
 顺序存储 链式存储 索引存储 散列存储
     
 顺序存储特点: 逻辑上相邻的两个元素 在实际的物理存储上也是相邻的 
 优点:是可以实现随机存取 每个元素占用最少的存储空间 且可以支持随即查找
 缺点：是只能使用相邻一整块的存储空间 因此可能会产生更多的外部碎片
     
 链式存储: 逻辑上相邻的两个元素 实际的物理存储上不一定相邻的 借助指示元素
     存储地址指针来表示元素之间的逻辑关系
     优点: 不会产生碎片现象 能充分利用存储单元
     缺点: 每个元素因为指针占用额外的空间 并且只能够遍历进行查找
         
 索引存储: 索引存储顾名思义就类似于操作系统中的虚拟内存的页表 或者是文件系统
     中或者Cache所设计的索引表 一般索引表是单独存放在内存的一块区域独立于
     数据元素存储的位置 一般索引表就是 数据元素key：对应位置 两个元素
     优点: 就是可以根据索引表的映射很快的得出元素的具体地址
     缺点: 需要额外的空间去存储索引表(//删除添加时候会修改索引表)
 散列存储: 通过一定的Hash函数进行计算直接的得出计算的地址
     优点: 查询的速度快
     缺点: 如果Hash函数设计的不好的话 会存在Hash碰撞的情况
         
4：算法以及其描述
   对特定问题求解步骤的描述 是指令的有限序列 每条指令表示一个或者多个操作
   重要包括五个特性: 1-有穷性 2-确定性 3-可行性 4：input 5：output
   好算法: 正确性 可读性 健壮性(处理非法数据问题) 效率与地存储量需求
   主要衡量: 时间复杂度以及空间复杂度
    有穷性定义 - 算法可以在执行有穷步骤之后完成 并且每个步骤是有穷步
    确定性定义 - 每个输入只有对应的一个输出

5：时间复杂度和空间复杂度
    首先一个算法优先考虑的应该是实现解答步骤所需要的时间复杂度 其中复杂度一般计算
    的方式是对需要执行最多次数的一个步骤来概括(即是时间复杂度最高的一步)
    时间复杂度又包括最坏时间复杂度和最好时间复杂度以及平均复杂度(采用最坏来判定)     用BigO来判定 / 主要规则有加法规则和乘法原则
  空间复杂度: 主要就是除了代码自身的变量 常量 输入输出之外所需要依靠外部开辟的
    数据结构所占用的大小来决定的(即是辅助空间) 空间复杂度与算法本身是没有关系的
   
 6：线性表的应用
         
 7:树的基本概念
    定义-n个结点的有限集合 
      1：有且仅有一个根节点
      2：其余节点分为几个互不相交的集合 其中集合本身又是一棵树 称为根节点子树
      3：除了根节点没有前驱结点 其他都是唯一一个 可以有一个或者多个后继节点
 
 8：二叉树的概念
     定义-在树的基础上进行拓展 - 每个节点至多只有两棵子树
       1：左右节点不可以颠倒
         
 9：树和森林相关内容
      1：树的存储方式
      双亲表示法: 本质上就是数组存储一个Node其中包括data和parent其中
       parent是祖先结点的下标
      2：孩子表示法
        每个结点的所有孩子都用一个单链表连接起来
      3：孩子兄弟表示法(二叉树表示法) --主要的就是转换过程中需要使用的
      转换方式左孩子右兄弟: -- 用实际题目去体验即可
         
 10:图的基本概念
   定义: 由有限的点集和边集构成的结构，//其中图不可以为空图
   最小生成树 - 包括n结点以及n-1结点
   简单图 - 没有重复边和自环边
   完全图 - 条数的判定以及各种保证结点是连通图的判定方式
   简单路径和简单回路的判定 - 路径是不包括重复的结点 简单回路-除了第一个和最后一个节点不会重复出现
   
   存储结构: 邻接矩阵(下标表示的是结点 内容如果是0或者1表示是否存在边) - 边集和点集的区别
            邻接表：(结合顺序存储和链式存储) - 其中结点存储链表结点-链表连接了当前结点的所有连通结点
                   (注意有向图和无向图之间的区别) --也就是遍历时间复杂度的问题(无向图多边)
   宽度优先遍历: set Queue弹出打印然后根据set加入点集的结点
   深度优先遍历: set Stack压入打印 - 判定了不存在这个邻接点之后 压入当前结点和邻接结点
   拓扑排序: zeroInQueue List<>result set map/ 
            初始化map如果有入度为0的就添加进入queue中 弹出queue加入result并且加入set 剩下的
            消除影响(保证不在set中) 如果有入度为0的加入zeroInQueue然后重复
   克鲁索最小生成树: heap(优先级队列)-定义小根堆的比较器 并查集UnionFindSet result(存储返回的边)
            -随便一个结点将 边集edges全部加入heap中(小根堆) 弹出一条边用并查集判断to和from结点
            是不是同一个集合 如果不是的话边就加入result() -重复即可
   最小生成树p算法: heap(同样存储edges) set判断toNode是否已经加入 result
            -其实思想和K算法差不多 但是p算法是由一个点开始进行边的加入并且判断对应toNode是否加入set
           注意需要遍历Nodes点集合(是为了防止森林的情况)
           如果set没有这个node-就解锁node的所有边(加入heap中) 弹出一条边即可判断toNode是否包含内部
           如果没有就加入这条边同时也解锁toNode所有的边-重复上面的步骤
   最短路径算法迪杰斯特拉: distanceMap最终需要返回的map / selectedNode(set集合) /黑盒:获取当前
            结点距离最短并且没有被选中过的结点
           distanceMap加入head以及距离0- 黑盒获取node-遍历node的边集并且开始处理如果toNode没有
           在集合中 然后判断是否原来的距离和现在 根据上面点的路径两者谁更近
           结束后set添加 并且重新选出minDistanceNode
   最短路径BFS: 宽度优先遍历在处理(原来是打印现在将map的distance+1即可)
   最短路径弗洛伊德: 传入邻接矩阵+自身根据定义的path矩阵 
           三层for循环 前两层是遍历matrix 最后是根据中转结点k来进行判断
           if(a[i][j] > a[i][k]+a[k][j]){
               更新a[i][j] path[i][j] = k
           }
   对应最短路径的适用范围: BFS只能无权图 Dij只能不包含负权图 Floy可以
   关键路径问题: 求解的步骤:
    1:首先利用拓扑排序先将事件进行先后排序-从入度为0的开始推导 得到各个事件的最早开始时间
    2：逆拓扑排序: 得到每一个事件的最晚开始时间
    3:推出每一个活动的最早开始时间
    4：同理推出每一个活动的最晚开始时间 (最早开始时间==最晚开始时间的为关键活动)
    5：利用最晚开始时间-最早开始时间就是每一个活动的时间余量
         
11：B树相关的问题
   首先是关于结点和关键字个数的规定
   1：由于B树需要满足绝对的平衡因此除根节点最少有2个结点以及1个关键字之外
   2：由于关键字个数过少的话 会造成b树查找效率的低下 因此硬性规定了B树
     除根节点之外的所有节点 最少要有m/2上整结点个数 m/2-1的关键字个数
   3：因此就可以引出m树的最大和最小高度问题
      最小高度:比较好计算即满足每一层结点个数最多即可
        1+m+m方+...m的h-1次方 
        关键字个数: 即是 结点个数*(m-1)
      最大高度: 即是满足每层节点个数最少即可 不妨定义m/2上整为k
        则
```

![image-20220410074239136](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220410074239136.png)

```java
12:散列表相关的问题:
  1：散列表的基本概念 
    首先引入应该要和一般的线性表以及树表进行对比 表中位置的记录和关键字之间是没有直接映射的关系 不能够通过关键字的情况直接反应出存储的位置
而散列函数可以直接通过关键字进行计算得出 元素的存储位置(这个位置可以是直接地址 或者数组下标等等)
   注意: 散列函数定义域必须包含全部关键字 至于范围大于散列表或者地址范围
    散列函数计算地址应该能够等概率均匀的分布在地址空间 从而减少冲突
    散列函数的计算应该尽量简短快速 从而计算得到地址
  2:散列函数的构造方法
      除留余数法(选择与当前key小于最接近的 质数p) - key%p
      直接定址法(a*key+b)
      数字分析法 平方取中法
     --但是实际上的构造还是应当根据关键字本身的情况而选择散列函数构造方法
  3：处理冲突的方法
      1：开放定址法 -- 两者优缺点-是否存在堆积问题
       (key+di)%m
       其中对于di得取值 又可以细化分为
       线性探测法: dio.1---k 其中k<m即可
       平方探测法 di得取值
       伪随机序列法
      2：拉链法 - 也是最常用的方式
           
13：广义表
   头尾链表存储结构 - 广义表结点以及原子节点
   扩展线性表存储结构 - 一种结构体变量作为表结点
```





















1：栈和队列复习

```java
基本栈的实现-利用数组
package LinkedList;

import java.util.Objects;

public class Review_StackTest {
    class Stack<V>{
        int size;
        V arr[];
        int index;
        public Stack(){
            size = 0;
            arr = (V[]) new Objects[1000];
            index = -1;
        }
        public int Size(){
            return size;
        }

        public void push(V v){
            if(index+1 >= arr.length/2){
                V newArr[] = (V[]) new Objects[(int)(arr.length * 1.5)];
                for(int i=0; i<size; i++){
                    newArr[i] = arr[i];
                }
                arr = newArr;
            }
            arr[++index] = v;
            size++;
        }

        public V pop(){
            if(size != 0){
                V v = arr[index];
                arr[index--] = null;
                return v;
            }
            return null;
        }

        public V peek(){
            return arr[index];
        }
    }

    class Queue<V>{
        int size;
        int beginIndex;
        int lastIndex;
        V arr[];
        public Queue(){
            size = 0;
            beginIndex = 0;
            lastIndex = -1;
            arr = (V[]) new Objects[1000];
        }
        public int size(){
            return size;
        }
        public void push(V v){
            if(lastIndex-beginIndex+1 >= size/2){
                V newArr[] = (V[]) new Objects[(int)(arr.length * 1.5)];
                int a = 0;
                for(int i=beginIndex; i<= lastIndex; i++){
                    newArr[a++] = arr[i];
                }
                arr = newArr;
                beginIndex = 0;
                lastIndex = a;
            }
            arr[++lastIndex] = v;
        }
        public V pop(){
            if(size != 0){
                V v = arr[lastIndex];
                arr[lastIndex--] = null;
                return v;
            }
            return null;
        }
        public V peek(){
            return arr[lastIndex];
        }
    }
}
基本的逻辑结构方式的进行就是根据指针进行操作
其中队列需要前后两个指针因为要先进先出
    
2：循环队列的采用
   主要是循环队列区分判断队满和队空两种情况选择:
   牺牲掉结尾的一个空间进行存储 因此
   队满的判断 (rear+1)%MmaxSize == front;
   队空的判断 rear == front;
   队列大小情况 (rear-front+maxSize)%maxSize

3.共享栈的细节使用
  起始开头: index =-1 // endIndex = arr.length-1;
  栈的推动: ++index 以及endIndex--前后是有差别的
  栈满的情况: index+1 == endIndex
      
      
4:栈和队列的应用
   1：后缀数组求值
      准备一个栈遇见数字首先直接压入，遇见一个字符弹出栈的两个元素
      然后同符号计算之后再压入栈中 反复进行(遍历String到结尾)
      最后return stack.peek();即可
   2：中缀数组转换为后缀数组
      准备两个栈 分别存储 操作数和运算符号(因为中缀数组包括())
      因此遵循以下的操作顺序:
 	  遇见操作数直接打印即可 遇见(压入 遇见)弹出并且打印直到遇见(
      其中(只是弹出但是不打印 遇见字符弹出所有优先级大于和等于自身的运算符
      之后再把自身运算符入栈即可
   3：中缀数组求值(结合1和2即可)
      可以中缀生成了后缀之后 再利用后缀进行运算
   4：一般的括号匹配问题       
       简单的将左括号方式的话 就全部压入栈 遇见右括号的话 对应必须要
       找到相关的左括号否则直接报错 最后判断栈是否为空即可
         
5：双端队列问题
6：特殊矩阵的压缩
    1：三角矩阵
    2：三对角矩阵
    3：稀疏矩阵
```

```java
2：链表相关问题:
链表基本定义
 1.头插法和尾插法
   那么为了实现必须包含需要的头部指针和尾部指针 
   Node head Node lastIndex
   同时也是可以当作一个逻辑上的链队
 2:双链表 循环单链表 循环双链表 静态链表
```























































































<span name = "1027">![image-20220404205603852](C:\Users\16953\AppData\Roaming\Typora\typora-user-images\image-20220404205603852.png)</span>



































